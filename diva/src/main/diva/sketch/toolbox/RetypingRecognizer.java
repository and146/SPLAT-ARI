/*
 * $Id: RetypingRecognizer.java,v 1.3 2001/08/28 06:37:13 hwawen Exp $
 *
 * Copyright (c) 1998-2001 The Regents of the University of California.
 * All rights reserved. See the file COPYRIGHT for details.
 */
package diva.sketch.toolbox;

import diva.sketch.recognition.StrokeRecognizer;
import diva.sketch.recognition.Recognition;
import diva.sketch.recognition.RecognitionSet;
import diva.sketch.recognition.TimedStroke;
import diva.sketch.recognition.Type;
import diva.sketch.recognition.SimpleData;

import java.util.HashMap;
import java.util.Iterator;

/**
 * FIXME
 *
 * @author Michael Shilman  (michaels@eecs.berkeley.edu)
 * @version $Revision: 1.3 $
 * @rating Red
 */
public class RetypingRecognizer implements StrokeRecognizer {
    /**
     * The recognizer that performs low-level recognition on strokes.
     */
    StrokeRecognizer _llr;

    /**
     * The set of types that are allowed through.
     */
    HashMap _allowedTypes;
    
    /**
     * Construct a filter recognizer which uses the given recognizer to
     * perform its low-level recognition.
     */
    public RetypingRecognizer(StrokeRecognizer llr){
        _llr = llr;
        _allowedTypes = new HashMap();
    }

    /**
     * Add a type that is allowed through by this filter
     * recognizer.  FIXME
     */
    public void addAllowedType(String allowedType, String mappedType) {
        _allowedTypes.put(allowedType, mappedType);
    }

    /**
     * Add a type that is allowed through by this filter
     * recognizer.  FIXME
     */
    public void addAllowedType(String allowedType) {
        _allowedTypes.put(allowedType, allowedType);
    }
    
    /**
     * Debugging output.
     */
    private void debug(String s) {
        System.err.println(s);
    }

    /**
     * Take a recognition set generated by the LLR and see whether or
     * not it contains some allowed types with non-zero confidences.
     * If so, return a RecognitionSet that contains the recognitions
     * of these allowed types.  If not, return NO_RECOGNITION.
     */
    protected RecognitionSet filterTypes(RecognitionSet in) {
        RecognitionSet out = RecognitionSet.NO_RECOGNITION;
        for(Iterator rs = in.recognitions(); rs.hasNext(); ) {
            Recognition rin = (Recognition)rs.next();
            String mappedID = (String)_allowedTypes.get(rin.getType().getID());
            if(mappedID != null && rin.getConfidence() > 0) {
                if(out == RecognitionSet.NO_RECOGNITION) { //lazy allocation
                    out = new RecognitionSet();
                }
                if(mappedID.equals(rin.getType().getID())) {
                    out.addRecognition(rin);
                }
                else {
                    out.addRecognition(new Recognition(new SimpleData(mappedID),
															 rin.getConfidence()));
                }
            }
        }
        return out;
    }

    /**
     * Remove a type that is allowed through by this filter
     * recognizer.
     */
    public void removeAllowedType(String typeID) {
        _allowedTypes.remove(typeID);
    }
    
    /**
     * Perform filtered recognition based on the LLR's
     * recognition on the stroke.
     */
    public RecognitionSet strokeCompleted(TimedStroke s) {
        return filterTypes(_llr.strokeCompleted(s));
    }

    /**
     * Perform filtered recognition based on the LLR's
     * recognition on the stroke.
     */
    public RecognitionSet strokeModified(TimedStroke s) {
        return filterTypes(_llr.strokeModified(s));
    }

    /**
     * Perform filtered recognition based on the LLR's
     * recognition on the stroke.
     */
    public RecognitionSet strokeStarted(TimedStroke s) {
        return filterTypes(_llr.strokeStarted(s));
    }
}


