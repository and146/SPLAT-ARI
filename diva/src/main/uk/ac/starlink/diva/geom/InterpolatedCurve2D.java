/*
 * Copyright (C) 2003 Central Laboratory of the Research Councils
 *
 *  History:
 *     18-NOV-2003 (Peter W. Draper):
 *       Original version.
 */
package uk.ac.starlink.diva.geom;

import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import uk.ac.starlink.diva.interp.Interpolator;
import uk.ac.starlink.diva.interp.InterpolatedCurveIterator;

/**
 * A curve generated by an interpolator between a series of vertices.
 *
 * @author Peter W. Draper
 * @version $Id$
 */
public class InterpolatedCurve2D
    implements Shape
{
    /**
     * The interpolation X coordinates.
     */
    double xCoords[] = null;

    /**
     * The interpolated Y coordinates.
     */
    double yCoords[] = null;

    /**
     * The interpolator used to estimate the curve between vertices.
     */
    Interpolator interpolator = null;

    /**
     * Whether we need to re-interpolate fully.
     */
    boolean recalc = true;

    /**
     * Whether the bounds need to be updated.
     */
    boolean rebound = true;

    /**
     * Create an empty instance.
     */
    public InterpolatedCurve2D( Interpolator interpolator )
    {
        setInterpolator( interpolator );
    }

    /**
     * Copy constructor.
     */
    public InterpolatedCurve2D( InterpolatedCurve2D in )
    {
        setInterpolator( in.interpolator );
        int count = in.getCoordCount();
        xCoords = new double[count];
        yCoords = new double[count];
        System.arraycopy( in.xCoords, 0, xCoords, 0, count );
        System.arraycopy( in.yCoords, 0, yCoords, 0, count );
    }

    /**
     * Set the interpolator.
     */
    public void setInterpolator( Interpolator interpolator )
    {
        this.interpolator = interpolator;

        // Start the interpolation for any existing vertices.
        int count = interpolator.getCount();
        if ( count > 0 ) {
            double[] vertices = interpolator.getXCoords();
            xCoords = new double[1];
            xCoords[0] = vertices[0];
            for ( int i = 1; i < vertices.length; i++ ) {
                extendXCoords( vertices[i] );
            }
            recalc = true;
        }
    }

    /**
     * Create extra X coordinates for interpolation points.
     */
    protected void extendXCoords( double newx )
    {
        if ( xCoords == null ) {
            return; // Could throw an exception.
        }
        int offset = xCoords.length;
        double prev = xCoords[offset-1];
        int nextra = interpolator.stepGuess();
        int newlength = offset + nextra;

        double[] temp = new double[newlength];

        double step = ( newx - prev ) / (double) nextra;

        System.arraycopy( xCoords, 0, temp, 0, offset );

        for ( int i = 0; i < nextra - 1; i++ ) {
            temp[offset+i] = prev + ( i + 1.0 ) * step;
        }
        temp[temp.length-1] = newx;
        xCoords = temp;

        recalc = true;
    }

    /**
     * Get the interpolator.
     */
    public Interpolator getInterpolator()
    {
        return interpolator;
    }

    //  Shape: Not closed so we never contain any points.
    public boolean contains( double x, double y )
    {
        return false;
    }
    public boolean contains( Point2D p )
    {
        return false;
    }
    public boolean contains( Rectangle2D r )
    {
        return false;
    }
    public boolean contains( double x, double y, double w, double h )
    {
        return false;
    }

    //  Shape: Ignore flatness, we do not implement that.
    public PathIterator getPathIterator( AffineTransform at,
                                         double flatness )
    {
        return getPathIterator( at );
    }
    public PathIterator getPathIterator ( AffineTransform at )
    {
        calculate();
        return new InterpolatedCurveIterator( this, at );
    }

    /**
     * Evaluate the interpolation.
     */
    public void calculate()
    {
        if ( recalc && xCoords != null && interpolator != null ) {
            yCoords = interpolator.evalYDataArray( xCoords );
            recalc = false;
            rebound = true;
        }
    }

    /**
     * Make sure the vertices are monotonic in some sense. Also
     * reinterpolates to refresh all positions. A mapping from old to
     * new indices is returned.
     */
    public int[] orderVertices()
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();

        int[] remap = insertionSort( x );
        y = applySortIndex( y, remap, isIncreasing() );

        interpolator.setCoords( x, y, true );
        setInterpolator( interpolator );

        return remap;
    }

    /**
     * Find out if X coordinates are increasing or decreasing.
     */
    public boolean isIncreasing()
    {
        return interpolator.isIncreasing();
    }

    /**
     * Get the number of vertices.
     */
    public int getVertexCount()
    {
        return interpolator.getCount();
    }

    /**
     * Get the number of coordinates.
     */
    public int getCoordCount()
    {
        if ( xCoords != null ) {
            calculate();
            return xCoords.length;
        }
        return 0;
    }

    // Shape: Test if our curve is intersected by the given rectangle.
    public boolean intersects( Rectangle2D r )
    {
        calculate();

        int count = getVertexCount();
        if ( count == 0 ) {
            return false;
        }
        else if ( count == 1 ) {
            return r.contains( getXVertex( 0 ), getYVertex( 0 ) );
        }

        count = xCoords.length;
        double x1;
        double y1;
        double x2 = xCoords[0];
        double y2 = yCoords[0];

        for ( int i = 1; i < count; i++ ) {
            x1 = x2;
            y1 = y2;
            x2 = xCoords[i];
            y2 = yCoords[i];
            if ( r.intersectsLine( x1, y1, x2, y2 ) ) {
                return true;
            }
        }
        return false;
    }

    // Shape:
    public boolean intersects( double x, double y, double w, double h )
    {
        return intersects( new Rectangle2D.Double( x, y, w, h ) );
    }

    /**
     * Add a new vertex at the end of the curve. This should also
     * generate the necessary interpolation coordinates.
     */
    public void lineTo( double x, double y )
    {
        interpolator.appendValue( x, y );
        orderVertices(); // Pick up new coordinates.
    }

    /**
     * Move the start point of the vertex to the given position.
     * Can only be done when curve is first created, or has been reset.
     *
     * @throws UnsupportedOperationException If this isn't the
     *                                       first vertex.
     */
    public void moveTo( double x, double y )
    {
        if ( getVertexCount() > 0 ) {
            throw new UnsupportedOperationException
                ( "InterpolatedCurve2D already has vertices" );
        }
        double[] xa = new double[1];
        double[] ya = new double[1];
        xa[0] = x;
        ya[0] = y;
        xCoords = new double[1];
        yCoords = new double[1];
        xCoords[0] = x;
        yCoords[0] = y;
        interpolator.setCoords( xa, ya, false );
    }

    public String toString()
    {
        String string = super.toString();
        StringBuffer buf = new StringBuffer( string );
        for ( int i = 0; i < getVertexCount(); i++ ) {
            buf.append( "(" + getXVertex( i ) + "," + getYVertex( i ) + ")," );
        }
        return buf.toString();
    }

    private Rectangle2D emptyBounds = new Rectangle2D.Double();
    private Rectangle2D currentBounds = emptyBounds;

    /**
     * Get the floating-point bounds. As approximate as the
     * drawn interpolated curve.
     */
    public Rectangle2D getBounds2D()
    {
        // If bounds haven't changed, do nothing.
        calculate();
        if ( rebound && xCoords != null ) {
            int count = xCoords.length;
            if ( count <= 1 ) {
                currentBounds = emptyBounds;
            }
            else {
                double x1 = xCoords[0];
                double y1 = yCoords[0];
                double x2 = x1;
                double y2 = y1;
                for ( int i = 1; i < count; i++ ) {
                    if ( xCoords[i] < x1 ) {
                        x1 = xCoords[i];
                    }
                    else if ( xCoords[i] > x2 ) {
                        x2 = xCoords[i];
                    }
                    if ( yCoords[i] < y1 ) {
                        y1 = yCoords[i];
                    }
                    else if ( yCoords[i] > y2 ) {
                        y2 = yCoords[i];
                    }
                }
                //  Add some slack for rounding errors...
                currentBounds = new Rectangle2D.Double( x1 - 6, y1 - 6,
                                                        x2 - x1 + 6,
                                                        y2 - y1 + 6 );
            }
            rebound = false;
        }
        return currentBounds;
    }
    public Rectangle getBounds()
    {
        return getBounds2D().getBounds();
    }

    // Check if an index is valid, if not throw an
    // IndexOutOfBoundsException, otherwise do nothing.
    private void checkIndex( int index )
    {
        calculate();
        if ( xCoords == null || index < 0 || index >= xCoords.length ) {
            throw new IndexOutOfBoundsException( "Index: " + index +
                                                 ", Size: " +
                                                 ( xCoords == null ?
                                                   0 : xCoords.length ) );
        }
    }

    /**
     * Get all interpolated X-coordinates.
     */
    public double[] getXCoords()
    {
        calculate();
        return xCoords;
    }

    /**
     * Get all interpolated Y-coordinates.
     */
    public double[] getYCoords()
    {
        calculate();
        return yCoords;
    }

    /**
     * Get an interpolated X-coordinate
     */
    public double getXCoord( int index )
    {
        checkIndex( index );
        return xCoords[index];
    }

    /**
     * Get a interpolated Y-coordinate.
     */
    public double getYCoord( int index )
    {
        checkIndex( index );
        return yCoords[index];
    }

    /**
     * Return if the Interpolator is full, i.e. will ignore or refuse any
     * further vectices.
     */
    public boolean isFull()
    {
        return interpolator.isFull();
    }

    /**
     * Get all the X vertices.
     */
    public double[] getXVertices()
    {
        return interpolator.getXCoords();
    }

    /**
     * Get all the Y vertices.
     */
    public double[] getYVertices()
    {
        return interpolator.getYCoords();
    }

    /**
     * Get the X-coordinate of a vertex.
     */
    public double getXVertex( int index )
    {
        return interpolator.getXCoord( index );
    }

    /**
     * Get the Y-coordinate of a vertex.
     */
    public double getYVertex( int index )
    {
        return interpolator.getYCoord( index );
    }

    /**
     * Set the X-coordinate of a vertex.
     */
    public void setXVertex( int index, double value )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        x[index] = value;
        interpolator.setCoords( x, y, false );
        setInterpolator( interpolator );
    }

    /**
     * Set the Y-coordinate of a vertex.
     */
    public void setYVertex( int index, double value )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        y[index] = value;
        interpolator.setCoords( x, y, false );
        setInterpolator( interpolator );
    }

    /**
     * Set the coordinates of a vertex.
     */
    public void setVertex( int index, double xValue, double yValue )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        x[index] = xValue;
        y[index] = yValue;
        interpolator.setCoords( x, y, false );
        setInterpolator( interpolator );
    }

    /**
     * Translate the coordinates of a vertex.
     * <p>
     * If recalc is false then a full re-calculation of the
     * interpolation coordinates is not performed. This can be used to
     * defer full re-calculations (if this or other vertices are to be
     * modified almost immediately) but the user must call either
     * {@link orderVertices} or {@link setInterpolator} (this can be
     * with the same interpolator as is currently in use) to force an
     * eventual re-calculation.
     * <p>
     * Translation of a vertex is contrained to not break the
     * monotonic nature of X coordinates, so if an attempt to move
     * past another vertex is made this will not be successful.
     */
    public void translateVertex( int index, double dx, double dy,
                                 boolean recalc )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();

        //  Constrain vertex to lie within its current X range. End
        //  points can move freely.
        double x0 = -Double.MAX_VALUE;
        if ( index > 0 ) {
            x0 = x[index-1];
        }

        double xp = x[index] + dx;

        double x1 = Double.MAX_VALUE;
        if ( index < x.length-1 ) {
            x1 = x[index+1];
        }

        x[index] = xp;
        y[index] += dy;
        interpolator.setCoords( x, y, false );
        if ( recalc ) {
            setInterpolator( interpolator );
        }
    }
    private static final double DELTAX = 2.0;

    /**
     * Transform the vertex positions.
     */
    public void transform( AffineTransform at )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();
        double[] xy = new double[x.length*2];
        int j = 0;
        for ( int i = 0; i < x.length; i++ ) {
            xy[j++] = x[i];
            xy[j++] = y[i];
        }
        at.transform( xy, 0, xy, 0, x.length );
        j = 0;
        for ( int i = 0; i < x.length; i++ ) {
            x[i] = xy[j++];
            y[i] = xy[j++];
        }
        interpolator.setCoords( x, y, true );
        setInterpolator( interpolator );
    }

    /**
     * Translate the vertex positions.
     */
    public void translate( double dx, double dy )
    {
        double[] x = interpolator.getXCoords();
        double[] y = interpolator.getYCoords();

        for ( int i = 0; i < x.length; i++ ) {
            x[i] += dx;
            y[i] += dy;
        }
        interpolator.setCoords( x, y, false );
        setInterpolator( interpolator );
    }

    /**
     * Creates an index that sorts a double precision array. On exit a
     * is sorted. A reordering of associated arrays can be performed
     * using the {@link applySortIndex} methods.
     */
    public static int[] insertionSort( double[] a )
    {
        //  XXX move this in UTIL package sometime.
        int size = a.length;
        int[] remap = new int[a.length];

        int i;
        int j;
        double v;

        for ( i = 1; i < size; i++ ) {
            v = a[i];
            j = i;
            while ( ( j > 0 ) && ( a[j-1] > v ) ) {
                remap[j] = j-1;
                a[j] = a[j-1];
                j--;
            }
            remap[j] = i;
            a[j] = v;
        }

        return remap;
    }

    /**
     * Sort an array using the index produced by the
     * {@link #insertionSort} method.
     */
    public static double[] applySortIndex( double[] a, int[] remap,
                                           boolean incr )
    {
        //  XXX move this in UTIL package sometime.
        int size = a.length;
        double[] newa = new double[size];
        if ( incr ) {
            for ( int j = 0; j < size; j++ ) {
                newa[j] = a[remap[j]];
            }
        }
        else {
            int i = size - 1 ;
            for ( int j = 0; j < size; j++ ) {
                newa[j] = a[remap[i--]];
            }
        }
        return newa;
    }
}
