These are tips on how the JNIAST package builds and how you should go
about updating it to match new versions of AST.

JNIAST is a bit more complicated than the other starjava packages,
partly because JNI is naturally harder than pure java to build, 
and partly because it works quite hard to extract documentation from
the AST source files and turn them into javadocs.  Although the
resulting built package is (fairly) well documented, some of the
machinery which builds it is, alas, not so beautiful.

Source files
============

   jniast/src/ast
      Files taken from the AST distribution (or CVS).  In most cases 
      they are C files from which the perl scripts extract comments
      to make javadocs.

   jniast/src/jni
      C files which are compiled to produce the native libraries.
      Some of these are autogenerated by the build-source target,
      so should not be edited (these are clearly marked by comments 
      at the top).

      The compilation is actually done using an old-style mk script -
      probably there are better ways of doing this (e.g. there's an
      ant <cc> task somewhere I think).

      The C code here is highly defensive.  This sort of thing 
      (e.g. checking for an exception every time there might possibly 
      be one) is necessary to prevent core dumps, which you don't
      expect to see in running Java.

   jniast/src/lib
      Contains a jniast_libs.jar file containing the native library for
      each supported architecture.  A normal build just unpacks these. 
      Ant build-native regenerates the one for the current 
      architecture and writes it back here.  If you have upgraded 
      JNIAST you can commit the resulting jar file; probably best
      to arrange to do it for all architectures at a similar time
      though.  Peter is the expert on the x86 DLLs.

   jniast/src/main/uk/ac/starlink/ast
      Contains java source files.  Some of these are written by hand
      (true source files) and others are autogenerated by the
      ant build-source target, and hence should not be edited.
      These latter are marked clearly with comments at the top.

   jniast/src/perl
      Contains perl scripts which are used to autogenerate 'source'
      files.  The .pl files are scripts which are invoked from 
      build.xml using <exec> tasks.  There are two perl modules here:

         SrcReader.pm
            Knows how to look through an AST C source file and pull
            out mehod names, descriptions, purposes etc.  Contains
            methods to access these.

         JMaker.pm
            Knows how to write bits of java source files.

      The .pl files which generate java source files for classes which
      match AST classes generally 'use' both of these modules.
      'use SrcReader' populates data structures with information
      gleaned from the comments in a given source file (specified
      when the script is invoked, in build.xml).  The scripts then
      make use of these using a combination of JMaker methods and
      straight print statements to spit out a java source file.

      I'm afraid none of the perl files are very beautifully laid out
      or documented (except in so far as the code is self-documenting,
      which it is, a bit).  You'll have to follow the examples of 
      existing files.

   jniast/src/testcases/uk/ac/starlink/ast
      JUnit test cases.  Pretty much every native method is tested by
      these (mostly by methods in the far-too-big-ought-to-get-split-up
      AstTest).  The tests are mainly that the native method can be 
      called without causing a core dump, but where I understand what
      the AST code is doing I've included some more assertive checks.

Build file targets
==================

As well as the standard ant targets (build, install, etc) JNIAST contains
some special ones which are not by default invoked by the top-level
starjava build:

   build-source:
      This makes sure that all the java and C files are up to date;
      some of these are autogenerated by running perl scripts as
      defined in build.xml.  The results are written into the relevant
      parts of the jniast/src tree, i.e. overwriting source files checked
      into CVS.  The output of these scripts is (should be) reproducible,
      so running "ant build-source" followed by a "cvs -n update"
      should reveal no differences as long as the *true* source files
      (including the files from src/ast and src/perl) have not changed.
      If you do change src/ast and src/perl files you should run
      ant build-source and check in the resulting changed source files.

   build-native:
      Builds the native library. 


Relationship of JNIAST to AST
=============================

The class structure of JNIAST exactly mirrors that of AST, for classes
descending from AstObject.

JNIAST constructors do not have "options" string arguments.
JNIAST objects have explicit get/set methods for each attribute;
although AstObject (and its subclasses) do have get/set<X> methods,
they are informally deprecated in favour of explicit accessor methods
for each attribute.  I consider these interface changes to be in 
the spirit of java's fussiness/type-safety (better not to specify
an attribute by name, since then the compiler can't spot if you're
wrong).

How to add a new class
======================

This gives a primer on how to upgrade JNIAST when a new class, here called
XxxMap, is added to AST.

   1. Copy the xxxmap.c file from the AST sources to jniast/src/ast/

   2. Write a new file jniast/src/perl/XxxMap.pl.  This is probably
      going to contain a makeNativeConstructor() call and several
      makeNativeMethod() and makeGetAttrib()/makeSetAttrib() calls,
      along with some boilerplate (and possibly some custom) print'ed
      output.  How to do this is not well documented I'm afraid, 
      you'll have to use one of the existing ones as a template.

   3. Add the perl invocation and javah invocations in build.xml
      (follow the pattern for existing classes, e.g. grep for LutMap
      and copy).

   4. Run "ant build-source" - this should create a new file 
      jniast/src/main/uk/ac/starlink/XxxMap.java

   5. Run "ant build" - this should compile XxxMap.java to a class file.
      If there's trouble, edit the XxxMap.pl (not XxxMap.java!) and
      go back to 4.

   6. Run "ant build-native".  This won't incorporate your new object
      because you haven't written the C code yet, but it will create
      a file jniast/build/jni/uk_ac_starlink_ast_XxxMap.h.  You can
      look at this to see what the prototypes are for the C functions
      you need to write.

   7. Add an entry for AstXxxMap in jniast/src/jni/jniast.h.

   8. Write a new file jniast/src/jni/XxxMap.c.  Crib from an existing
      C file in src/jni/.  And read the JNI specification first.
      #include "uk_ac_starlink_ast_XxxMap.h" and make sure you 
      include functions matching each prototype in it.

   9. Add an entry for XxxMap.c in jniast/src/jni/makefile.

  10. Run "ant build-native"

  11. Write a test case (in jniast/src/testcases/uk/ac/starlink/ast/AstTest
      or some other class in that directory) which invokes every one
      of the methods of your new class.  Your test code needs to be
      within a method 'public void test*()' in a public class called
      *Test.java.  You won't miss this one out now, will you.  
      That JNI is tricky and you'll often find that 
      you get a core dump when you don't expect to.

  12. Run the unit tests using 'ant test'.  When it all works, check
      in the new source files, including new automatically generated
      ones and the new native library jars.  Get these compiled
      for all the supported systems (ant buld-native on all supported
      systems).

  13. You may want to upgrade the version of JNIAST.  The JNIAST version
      currently tracks the version number of AST (the JNIAST version 
      number is the earliest version of AST which JNIAST requires to run).
      This is currently rather a mess; you need to change version numbers
      in the source files 
          jniast/build.xml
          jniast/src/jni/jniast.h
          jniast/src/perl/AstObject.pl
          jniast/src/testcases/uk/ac/starlink/ast/AstTest.java
      then run ant build-source to regenerate
          jniast/src/main/uk/ac/starlink/ast/AstObject.java


