/* ********************************************************
 * This file automatically generated by Mapping.pl.
 *                   Do not edit.                         *
 **********************************************************/

package uk.ac.starlink.ast;


/**
 * Java interface to the AST Mapping class
 *  - inter-relate two coordinate systems. 
 * This class provides the basic facilities for transforming a set
 * of coordinates (representing "input" points) to give a new set
 * of coordinates (representing "output" points).  It is used to
 * describe the relationship which exists between two different
 * coordinate systems and to implement operations which make use of
 * this (such as transforming coordinates and resampling grids of
 * data).  However, the Mapping class does not have a constructor
 * function of its own, as it is simply a container class for a
 * family of specialised Mappings which implement particular types
 * of coordinate transformation.
 * <h4>Licence</h4>
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public Licence as
 * published by the Free Software Foundation; either version 2 of
 * the Licence, or (at your option) any later version.
 * <p>
 * This program is distributed in the hope that it will be
 * useful,but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU General Public Licence for more details.
 * <p>
 * You should have received a copy of the GNU General Public Licence
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
 * 02110-1301, USA
 * 
 * 
 * @see  <a href='http://star-www.rl.ac.uk/cgi-bin/htxserver/sun211.htx/?xref_Mapping'>AST Mapping</a>  
 */
public class Mapping extends AstObject {

    /**
     * A nearest-neighbour interpolator for use in the resampling methods.
     * Provided static for convenience.
     */
    public static final Interpolator NEAREST_INTERPOLATOR =
        Interpolator.nearest();

    /**
     * A linear interpolator for use in the resampling methods.
     * Provided static for convenience.
     */
    public static final Interpolator LINEAR_INTERPOLATOR =
        Interpolator.linear();

    /**
     * A nearest-neighbour spreader for use in the rebinning methods.
     * Provided static for convenience.
     */
    public static final Spreader NEAREST_SPREADER =
        Spreader.nearest();

    /**
     * A linear spreader for use in the rebinning methods.
     * Provided static for convenience.
     */
    public static final Spreader LINEAR_SPREADER =
        Spreader.linear();

    /**
     * Perform initialization required for JNI code at class load time.
     */
    static {
        nativeInitializeMapping();
    }
    private native static void nativeInitializeMapping();

    /**
     * Dummy constructor.  This constructor does not create a valid
     * Mapping object, but is required for inheritance by Mapping's
     * subclasses.
     */
    protected Mapping() {
    }

    /**
     * Inverts a mapping by reversing the sense of its Invert attribute.
     */
    public void invert() {
        setInvert( ! getInvert() );
    }

    /** 
     * Simplify a Mapping.   
     * This function simplifies a Mapping (which may be a compound
     * Mapping such as a CmpMap) to eliminate redundant computational
     * steps, or to merge separate steps which can be performed more
     * efficiently in a single operation.
     * <p>
     * As a simple example, a Mapping which multiplied coordinates by
     * 5, and then multiplied the result by 10, could be simplified to
     * a single step which multiplied by 50. Similarly, a Mapping which
     * multiplied by 5, and then divided by 5, could be reduced to a
     * simple copying operation.
     * <p>
     * This function should typically be applied to Mappings which have
     * undergone substantial processing or have been formed by merging
     * other Mappings. It is of potential benefit, for example, in
     * reducing execution time if applied before using a Mapping to
     * transform a large number of coordinates.
     * <h4>Notes</h4>
     * <br> - This function can safely be applied even to Mappings which
     * cannot be simplified. If no simplification is possible, it
     * behaves exactly like astClone and returns a pointer to the
     * original Mapping.
     * <br> - The Mapping returned by this function may not be independent
     * of the original (even if simplification was possible), and
     * modifying it may therefore result in indirect modification of
     * the original. If a completely independent result is required, a
     * copy should be made using astCopy.
     * <br> - A null Object pointer (AST__NULL) will be returned if this
     * function is invoked with the AST error status set, or if it
     * should fail for any reason.
     * @return  A new pointer to the (possibly simplified) Mapping.
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public native Mapping simplify(  );

    /** 
     * Decompose a Mapping into two component Mappings.   
     * This function returns pointers to two Mappings which, when applied
     * either in series or parallel, are equivalent to the supplied Mapping.
     * <p>
     * Since the Frame class inherits from the Mapping class, Frames can
     * be considered as special types of Mappings and so this method can
     * be used to decompose either CmpMaps or CmpFrames.
     * <h4>Notes</h4>
     * <br> - The returned Invert values should be used in preference to the
     * current values of the Invert attribute in map1 and map2. This is
     * because the attributes may have changed value since the Mappings
     * were combined.
     * <br> - Any changes made to the component Mappings using the returned
     * pointers will be reflected in the supplied Mapping.
     * 
     * @param   series
     * A one-element array to hold a boolean result indicating whether
     *             the component Mappings are in series or not.  If true, the
     *             two Mappings should be joined in series to form this CmpMap,
     *             if false then in parallel.  For any object other than a 
     *             CmpMap, the returned value will be zero.
     *             If <code>null</code> is supplied, then the series information 
     *             is not returned.
     *          
     * @param   inverts
     * A two-element array to hold the Invert attribute vales for
     *             the constituent Mappings.  
     *             If <code>null</code> is supplied, then the inversion information
     *             is not returned.
     *          
     * @return  
     *          An array of Mappings giving the components of this Mapping.
     *          If this Mapping is a CmpMap, it will be a 2-element array
     *          holding the two constituent Mappings which were used to create
     *          this Mapping, either in series or in parallel. 
     *          If this Mapping is a CmpFrame, it will be a 2-element array 
     *          containing the two constituent Frames which were used to 
     *          create this CmpFrame in parallel.
     *          Otherwise, a 1-element array containing a clone of this 
     *          object will be returned.
     *       
     * @throws  AstException  if an error occurred in the AST library
     */
    public native Mapping[] decompose( boolean[] series, boolean[] inverts );

    /** 
     * Find a bounding box for a Mapping.   
     * This function allows you to find the "bounding box" which just
     * encloses another box after it has been transformed by a Mapping
     * (using either its forward or inverse transformation). A typical
     * use might be to calculate the size of an image after being
     * transformed by a Mapping.
     * <p>
     * The function works on one dimension at a time. When supplied
     * with the lower and upper bounds of a rectangular region (box) of
     * input coordinate space, it finds the lowest and highest values
     * taken by a nominated output coordinate within that
     * region. Optionally, it also returns the input coordinates where
     * these bounding values are attained. It should be used repeatedly
     * to obtain the extent of the bounding box in more than one
     * dimension.
     * <h4>Notes</h4>
     * <br> - Any input points which are transformed by the Mapping to give
     * output coordinates containing the value AST__BAD are regarded as
     * invalid and are ignored. They will make no contribution to
     * determining the output bounds, even although the nominated
     * output coordinate might still have a valid value at such points.
     * <br> - An error will occur if the required output bounds cannot be
     * found. Typically, this might happen if all the input points
     * which the function considers turn out to be invalid (see
     * above). The number of points considered before generating such
     * an error is quite large, so this is unlikely to occur by
     * accident unless valid points are restricted to a very small
     * subset of the input coordinate space.
     * <br> - The values returned via "lbnd_out", "ubnd_out", "xl" and "xu"
     * will be set to the value AST__BAD if this function should fail
     * for any reason. Their initial values on entry will not be
     * altered if the function is invoked with the AST error status
     * set.
     * @param   lbnd_in
     * Pointer to an array of double, with one element for each
     * Mapping input coordinate. This should contain the lower bound
     * of the input box in each input dimension.
     * 
     * @param   ubnd_in
     * Pointer to an array of double, with one element for each
     * Mapping input coordinate. This should contain the upper bound
     * of the input box in each input dimension.
     * <p>
     * Note that it is permissible for the upper bound to be less
     * than the corresponding lower bound, as the values will simply
     * be swapped before use.
     * 
     * @param   forward
     * If this value is non-zero, then the Mapping's forward
     * transformation will be used to transform the input
     * box. Otherwise, its inverse transformation will be used.
     * <p>
     * (If the inverse transformation is selected, then references
     * to "input" and "output" coordinates in this description
     * should be transposed. For example, the size of the "lbnd_in"
     * and "ubnd_in" arrays should match the number of output
     * coordinates, as given by the Mapping's Nout
     * attribute. Similarly, the "coord_out" parameter, below,
     * should nominate one of the Mapping's input coordinates.)
     * 
     * @param   coord_out
     * The index of the output coordinate for which the lower and
     * upper bounds are required. This value should be at least one,
     * and no larger than the number of Mapping output coordinates.
     * 
     * @param   xl
     * An optional pointer to an array of double, with one element
     * for each Mapping input coordinate. If given, this array will
     * be filled with the coordinates of an input point (although
     * not necessarily a unique one) for which the nominated output
     * coordinate attains the lower bound value returned in
     * "*lbnd_out".
     * <p>
     * If these coordinates are not required, a NULL pointer may be
     * supplied.
     * 
     * @param   xu
     * An optional pointer to an array of double, with one element
     * for each Mapping input coordinate. If given, this array will
     * be filled with the coordinates of an input point (although
     * not necessarily a unique one) for which the nominated output
     * coordinate attains the upper bound value returned in
     * "*ubnd_out".
     * <p>
     * If these coordinates are not required, a NULL pointer may be
     * supplied.
     * 
     * @return  
     *          a two-element array giving the lowest (element 0) and highest
     *          (element 1) value taken by the nominated output coordinate
     *          within the specified region of input space
     *       
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double[] mapBox( double[] lbnd_in, double[] ubnd_in, boolean forward, int coord_out, double[] xl, double[] xu );

    /** 
     * Split a Mapping up into parallel component Mappings.   
     * This function
     * creates a new Mapping which connects specified inputs within a
     * supplied Mapping to the corresponding outputs of the supplied Mapping.
     * This is only possible if the specified inputs correspond to some
     * subset of the Mapping outputs. That is, there must exist a subset of
     * the Mapping outputs for which each output depends only on the selected
     * Mapping inputs, and not on any of the inputs which have not been
     * selected. Also, any output which is not in this subset must not depend
     * on any of the selected inputs. If these conditions are not met by the
     * supplied Mapping, then
     * a NULL
     * Mapping pointer is returned.
     * <h4>Notes</h4>
     * <br> - If this
     * function
     * is invoked with the global error status set, or if it should fail for
     * any reason, then
     * a NULL value
     * will be returned for
     * the "map" pointer.
     * @param   in
     * Pointer to an
     * array holding the indices within the supplied Mapping of the inputs
     * which are to be picked from the Mapping.
     * This array should have "nin" elements.
     * If "Nin" is the number of inputs of the supplied Mapping, then each
     * element should have a value in the range 1 to Nin.
     * 
     * @param   out
     * Pointer to an
     * array in which to return the indices of the outputs of the supplied
     * Mapping which are fed by the picked inputs. A value of one is
     * used to refer to the first Mapping output. The supplied array should
     * have a length at least equal to the number of outputs in the
     * supplied Mapping. The number of values stored in the array on
     * exit will equal the number of outputs in the returned Mapping.
     * The i'th element in the returned array holds the index within
     * the supplied Mapping which corresponds to the i'th output of
     * the returned Mapping.
     * 
     * @return  
     *          the returned mapping
     *       
     * @throws  AstException  if an error occurred in the AST library
     */
    public native Mapping mapSplit( int[] in, int[] out );

    /** 
     * Resample a region of a data grid.   
     * This is a set of functions for resampling gridded data (e.g. an
     * image) under the control of a geometrical transformation, which
     * is specified by a Mapping.  The functions operate on a pair of
     * data grids (input and output), each of which may have any number
     * of dimensions. Resampling may be restricted to a specified
     * region of the output grid. An associated grid of error estimates
     * associated with the input data may also be supplied (in the form
     * of variance values), so as to produce error estimates for the
     * resampled output data. Propagation of missing data (bad pixels)
     * is supported.
     * <p>
     * You should use a resampling function which matches the numerical
     * type of the data you are processing by replacing <X> in
     * the generic function name astResample<X> by an appropriate 1- or
     * 2-character type code. For example, if you are resampling data
     * with type "float", you should use the function astResampleF (see
     * the "Data Type Codes" section below for the codes appropriate to
     * other numerical types).
     * <p>
     * Resampling of the grid of input data is performed by
     * transforming the coordinates of the centre of each output grid
     * element (or pixel) into the coordinate system of the input grid.
     * Since the resulting coordinates will not, in general, coincide
     * with the centre of an input pixel, sub-pixel interpolation is
     * performed between the neighbouring input pixels. This produces a
     * resampled value which is then assigned to the output pixel. A
     * choice of sub-pixel interpolation schemes is provided, but you
     * may also implement your own.
     * <p>
     * This algorithm samples the input data value, it does not integrate
     * it. Thus total data value in the input image will not, in general,
     * be conserved. However, an option is provided (see the "Control Flags"
     * section below) which can produce approximate flux conservation by
     * scaling the output values using the ratio of the output pixel size
     * to the input pixel size. However, if accurate flux conservation is
     * important to you, consder using the
     * astRebin<X> or astRebinSeq<X> family of functions
     * instead.
     * <p>
     * Output pixel coordinates are transformed into the coordinate
     * system of the input grid using the inverse transformation of the
     * Mapping which is supplied. This means that geometrical features
     * in the input data are subjected to the Mapping's forward
     * transformation as they are transferred from the input to the
     * output grid (although the Mapping's forward transformation is
     * not explicitly used).
     * <p>
     * In practice, transforming the coordinates of every pixel of a
     * large data grid can be time-consuming, especially if the Mapping
     * involves complicated functions, such as sky projections. To
     * improve performance, it is therefore possible to approximate
     * non-linear Mappings by a set of linear transformations which are
     * applied piece-wise to separate sub-regions of the data. This
     * approximation process is applied automatically by an adaptive
     * algorithm, under control of an accuracy criterion which
     * expresses the maximum tolerable geometrical distortion which may
     * be introduced, as a fraction of a pixel.
     * <p>
     * This algorithm first attempts to approximate the Mapping with a
     * linear transformation applied over the whole region of the
     * output grid which is being used. If this proves to be
     * insufficiently accurate, the output region is sub-divided into
     * two along its largest dimension and the process is repeated
     * within each of the resulting sub-regions. This process of
     * sub-division continues until a sufficiently good linear
     * approximation is found, or the region to which it is being
     * applied becomes too small (in which case the original Mapping is
     * used directly).
     * <h4>Notes</h4>
     * <br> - A value of zero will be returned if this function is invoked
     * with the global error status set, or if it should fail for any
     * reason.
     * <h4>Propagation of Missing Data</h4>
     * Unless the AST__NOBAD flag is specified, instances of missing data
     * (bad pixels) in the output grid are
     * identified by occurrences of the "badval" value in the "out"
     * array. These may be produced if any of the following happen:
     * <p>
     * <br> - The input position (the transformed position of the output
     * pixel's centre) lies outside the boundary of the grid of input
     * pixels.
     * <br> - The input position lies inside the boundary of a bad input
     * pixel. In this context, an input pixel is considered bad if its
     * data value is equal to "badval" and the AST__USEBAD flag is
     * set via the "flags" parameter.
     * (Positions which have half-integral coordinate values, and
     * therefore lie on a pixel boundary, are regarded as lying within
     * the pixel with the larger, i.e. more positive, index.)
     * <br> - The set of neighbouring input pixels (excluding those which
     * are bad) is unsuitable for calculating an interpolated
     * value. Whether this is true may depend on the sub-pixel
     * interpolation scheme in use.
     * <br> - The interpolated value lies outside the range which can be
     * represented using the data type of the "out" array.
     * <p>
     * In addition, associated output variance estimates (if
     * calculated) may be declared bad and flagged with the "badval"
     * value in the "out_var" array under any of the following
     * circumstances:
     * <p>
     * <br> - The associated resampled data value (in the "out" array) is bad.
     * <br> - The set of neighbouring input pixels which contributed to the
     * output data value do not all have valid variance estimates
     * associated with them. In this context, an input variance
     * estimate may be regarded as bad either because it has the value
     * "badval" (and the AST__USEBAD flag is set), or because it is
     * negative.
     * <br> - The set of neighbouring input pixels for which valid variance
     * values are available is unsuitable for calculating an overall
     * variance value. Whether this is true may depend on the sub-pixel
     * interpolation scheme in use.
     * <br> - The variance value lies outside the range which can be
     * represented using the data type of the "out_var" array.
     * <p>
     * If the AST__NOBAD flag is specified via
     * parameter "flags",
     * then output array elements that would otherwise be set to
     * "badval"
     * are instead left holding the value they had on entry to this
     * function. The number of such array elements is returned as
     * the function value.
     * @param   ndim_in
     * The number of dimensions in the input grid. This should be at
     * least one.
     * 
     * @param   lbnd_in
     * Pointer to an array of integers, with "ndim_in" elements,
     * containing the coordinates of the centre of the first pixel
     * in the input grid along each dimension.
     * 
     * @param   ubnd_in
     * Pointer to an array of integers, with "ndim_in" elements,
     * containing the coordinates of the centre of the last pixel in
     * the input grid along each dimension.
     * <p>
     * Note that "lbnd_in" and "ubnd_in" together define the shape
     * and size of the input grid, its extent along a particular
     * (j'th) dimension being ubnd_in[j]-lbnd_in[j]+1 (assuming the
     * index "j" to be zero-based). They also define
     * the input grid's coordinate system, each pixel having unit
     * extent along each dimension with integral coordinate values
     * at its centre.
     * 
     * @param   in
     * Pointer to an array, with one element for each pixel in the
     * input grid, containing the input data to be resampled.  The
     * numerical type of this array should match the 1- or
     * 2-character type code appended to the function name (e.g. if
     * you are using astResampleF, the type of each array element
     * should be "float").
     * <p>
     * The storage order of data within this array should be such
     * that the index of the first grid dimension varies most
     * rapidly and that of the final dimension least rapidly
     * (i.e. Fortran array indexing is used).
     * 
     * @param   in_var
     * An optional pointer to a second array with the same size and
     * type as the "in" array. If given, this should contain a set
     * of non-negative values which represent estimates of the
     * statistical variance associated with each element of the "in"
     * array. If this array is supplied (together with the
     * corresponding "out_var" array), then estimates of the
     * variance of the resampled output data will be calculated.
     * <p>
     * If no input variance estimates are being provided, a NULL
     * pointer should be given.
     * 
     * @param   interp
     * an <code>Interpolator</code> object which determines what
     *             sub-pixel interpolation scheme should be used for the
     *             resampling
     *          
     * @param   flags
     * flags object giving additional details about the resampling
     *             procedure
     *          
     * @param   tol
     * The maximum tolerable geometrical distortion which may be
     * introduced as a result of approximating non-linear Mappings
     * by a set of piece-wise linear transformations. This should be
     * expressed as a displacement in pixels in the input grid's
     * coordinate system.
     * <p>
     * If piece-wise linear approximation is not required, a value
     * of zero may be given. This will ensure that the Mapping is
     * used without any approximation, but may increase execution
     * time.
     * 
     * @param   maxpix
     * A value which specifies an initial scale size (in pixels) for
     * the adaptive algorithm which approximates non-linear Mappings
     * with piece-wise linear transformations. Normally, this should
     * be a large value (larger than any dimension of the region of
     * the output grid being used). In this case, a first attempt to
     * approximate the Mapping by a linear transformation will be
     * made over the entire output region.
     * <p>
     * If a smaller value is used, the output region will first be
     * divided into sub-regions whose size does not exceed "maxpix"
     * pixels in any dimension. Only at this point will attempts at
     * approximation commence.
     * <p>
     * This value may occasionally be useful in preventing false
     * convergence of the adaptive algorithm in cases where the
     * Mapping appears approximately linear on large scales, but has
     * irregularities (e.g. holes) on smaller scales. A value of,
     * say, 50 to 100 pixels can also be employed as a safeguard in
     * general-purpose software, since the effect on performance is
     * minimal.
     * <p>
     * If too small a value is given, it will have the effect of
     * inhibiting linear approximation altogether (equivalent to
     * setting "tol" to zero). Although this may degrade
     * performance, accurate results will still be obtained.
     * 
     * @param   badval
     * This argument should have the same type as the elements of
     * the "in" array. It specifies the value used to flag missing
     * data (bad pixels) in the input and output arrays.
     * <p>
     * If the AST__USEBAD flag is set via the "flags" parameter,
     * then this value is used to test for bad pixels in the "in"
     * (and "in_var") array(s).
     * <p>
     * Unless the AST__NOBAD flag is set via the "flags" parameter,
     * this value is also used to flag any output
     * elements in the "out" (and "out_var") array(s) for which
     * resampled values could not be obtained (see the "Propagation
     * of Missing Data" section below for details of the
     * circumstances under which this may occur). The astResample<X>
     * function return value indicates whether any such values have
     * been produced. If the AST__NOBAD flag is set. then output array
     * elements for which no resampled value could be obtained are
     * left set to the value they had on entry to this function.
     * 
     * @param   ndim_out
     * The number of dimensions in the output grid. This should be
     * at least one. It need not necessarily be equal to the number
     * of dimensions in the input grid.
     * 
     * @param   lbnd_out
     * Pointer to an array of integers, with "ndim_out" elements,
     * containing the coordinates of the centre of the first pixel
     * in the output grid along each dimension.
     * 
     * @param   ubnd_out
     * Pointer to an array of integers, with "ndim_out" elements,
     * containing the coordinates of the centre of the last pixel in
     * the output grid along each dimension.
     * <p>
     * Note that "lbnd_out" and "ubnd_out" together define the
     * shape, size and coordinate system of the output grid in the
     * same way as "lbnd_in" and "ubnd_in" define the shape, size
     * and coordinate system of the input grid.
     * 
     * @param   lbnd
     * Pointer to an array of integers, with "ndim_out" elements,
     * containing the coordinates of the first pixel in the region
     * of the output grid for which a resampled value is to be
     * calculated.
     * 
     * @param   ubnd
     * Pointer to an array of integers, with "ndim_out" elements,
     * containing the coordinates of the last pixel in the region of
     * the output grid for which a resampled value is to be
     * calculated.
     * <p>
     * Note that "lbnd" and "ubnd" together define the shape and
     * position of a (hyper-)rectangular region of the output grid
     * for which resampled values should be produced. This region
     * should lie wholly within the extent of the output grid (as
     * defined by the "lbnd_out" and "ubnd_out" arrays). Regions of
     * the output grid lying outside this region will not be
     * modified.
     * 
     * @param   out
     * Pointer to an array, with one element for each pixel in the
     * output grid, into which the resampled data values will be
     * returned. The numerical type of this array should match that
     * of the "in" array, and the data storage order should be such
     * that the index of the first grid dimension varies most
     * rapidly and that of the final dimension least rapidly
     * (i.e. Fortran array indexing is used).
     * 
     * @param   out_var
     * An optional pointer to an array with the same type and size
     * as the "out" array. If given, this array will be used to
     * return variance estimates for the resampled data values. This
     * array will only be used if the "in_var" array has also been
     * supplied.
     * <p>
     * The output variance values will be calculated on the
     * assumption that errors on the input data values are
     * statistically independent and that their variance estimates
     * may simply be summed (with appropriate weighting factors)
     * when several input pixels contribute to an output data
     * value. If this assumption is not valid, then the output error
     * estimates may be biased. In addition, note that the
     * statistical errors on neighbouring output data values (as
     * well as the estimates of those errors) may often be
     * correlated, even if the above assumption about the input data
     * is correct, because of the sub-pixel interpolation schemes
     * employed.
     * <p>
     * If no output variance estimates are required, a NULL pointer
     * should be given.
     * 
     * @return  The number of output pixels for which no valid resampled value
     * could be obtained. Thus, in the absence of any error, a returned
     * value of zero indicates that all the required output pixels
     * received valid resampled data values (and variances). See the
     * "badval" and "flags" parameters.
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public int resample( int ndim_in, int[] lbnd_in, int[] ubnd_in, Object in, Object in_var, Mapping.Interpolator interp, ResampleFlags flags, double tol, int maxpix, Number badval, int ndim_out, int[] lbnd_out, int[] ubnd_out, int[] lbnd, int[] ubnd, Object out, Object out_var ){
        Class type = in.getClass().getComponentType();
        try {
            if ( type == byte.class ) {
                return resampleB( ndim_in, lbnd_in, ubnd_in,
                                  (byte[]) in, (byte[]) in_var,
                                  interp, flags, tol, maxpix,
                                  ((Byte) badval).byteValue(),
                                  ndim_out, lbnd_out, ubnd_out, lbnd, ubnd,
                                  (byte[]) out, (byte[]) out_var );
            }
            else if ( type == short.class ) {
                return resampleS( ndim_in, lbnd_in, ubnd_in,
                                  (short[]) in, (short[]) in_var,
                                  interp, flags, tol, maxpix,
                                  ((Short) badval).shortValue(),
                                  ndim_out, lbnd_out, ubnd_out, lbnd, ubnd,
                                  (short[]) out, (short[]) out_var );
            }
            else if ( type == int.class ) {
                return resampleI( ndim_in, lbnd_in, ubnd_in,
                                  (int[]) in, (int[]) in_var,
                                  interp, flags, tol, maxpix,
                                  ((Integer) badval).intValue(),
                                  ndim_out, lbnd_out, ubnd_out, lbnd, ubnd,
                                  (int[]) out, (int[]) out_var );
            }
            else if ( type == long.class ) {
                return resampleL( ndim_in, lbnd_in, ubnd_in,
                                  (long[]) in, (long[]) in_var,
                                  interp, flags, tol, maxpix,
                                  ((Long) badval).longValue(),
                                  ndim_out, lbnd_out, ubnd_out, lbnd, ubnd,
                                  (long[]) out, (long[]) out_var );
            }
            else if ( type == float.class ) {
                return resampleF( ndim_in, lbnd_in, ubnd_in,
                                  (float[]) in, (float[]) in_var,
                                  interp, flags, tol, maxpix,
                                  ((Float) badval).floatValue(),
                                  ndim_out, lbnd_out, ubnd_out, lbnd, ubnd,
                                  (float[]) out, (float[]) out_var );
            }
            else if ( type == double.class ) {
                return resampleD( ndim_in, lbnd_in, ubnd_in,
                                  (double[]) in, (double[]) in_var,
                                  interp, flags, tol, maxpix,
                                  ((Double) badval).doubleValue(),
                                  ndim_out, lbnd_out, ubnd_out, lbnd, ubnd,
                                  (double[]) out, (double[]) out_var );
            }
            else {
                throw new ClassCastException( "dummy ClassCastException" );
            }
        }
        catch ( ClassCastException e ) {
                throw new IllegalArgumentException(
                    "in, in_var, out, out_var must be all arrays of the same "
                  + "primitive type, and badval a matching Number type" );
        }
    }
    /**
     * Resampling method specific to byte data - see the resample method.
     */
    public native int resampleB( 
        int ndim_in, int[] lbnd_in, int[] ubnd_in,
        byte[] in, byte[] in_var,
        Mapping.Interpolator interp, ResampleFlags flags, double tol,
        int maxpix,
        byte badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
        int[] lbnd, int[] ubnd,
        byte[] out, byte[] out_var );

    /**
     * Resampling method specific to short data - see the resample method.
     */
    public native int resampleS( 
        int ndim_in, int[] lbnd_in, int[] ubnd_in,
        short[] in, short[] in_var,
        Mapping.Interpolator interp, ResampleFlags flags, double tol,
        int maxpix,
        short badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
        int[] lbnd, int[] ubnd,
        short[] out, short[] out_var );

    /**
     * Resampling method specific to int data - see the resample method.
     */
    public native int resampleI( 
        int ndim_in, int[] lbnd_in, int[] ubnd_in,
        int[] in, int[] in_var,
        Mapping.Interpolator interp, ResampleFlags flags, double tol,
        int maxpix,
        int badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
        int[] lbnd, int[] ubnd,
        int[] out, int[] out_var );

    /**
     * Resampling method specific to long data - see the resample method.
     */
    public native int resampleL( 
        int ndim_in, int[] lbnd_in, int[] ubnd_in,
        long[] in, long[] in_var,
        Mapping.Interpolator interp, ResampleFlags flags, double tol,
        int maxpix,
        long badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
        int[] lbnd, int[] ubnd,
        long[] out, long[] out_var );

    /**
     * Resampling method specific to float data - see the resample method.
     */
    public native int resampleF( 
        int ndim_in, int[] lbnd_in, int[] ubnd_in,
        float[] in, float[] in_var,
        Mapping.Interpolator interp, ResampleFlags flags, double tol,
        int maxpix,
        float badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
        int[] lbnd, int[] ubnd,
        float[] out, float[] out_var );

    /**
     * Resampling method specific to double data - see the resample method.
     */
    public native int resampleD( 
        int ndim_in, int[] lbnd_in, int[] ubnd_in,
        double[] in, double[] in_var,
        Mapping.Interpolator interp, ResampleFlags flags, double tol,
        int maxpix,
        double badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
        int[] lbnd, int[] ubnd,
        double[] out, double[] out_var );

    /** 
     * Rebin a region of a data grid.   
     * This is a set of functions for rebinning gridded data (e.g. an
     * image) under the control of a geometrical transformation, which
     * is specified by a Mapping.  The functions operate on a pair of
     * data grids (input and output), each of which may have any number
     * of dimensions. Rebinning may be restricted to a specified
     * region of the input grid. An associated grid of error estimates
     * associated with the input data may also be supplied (in the form
     * of variance values), so as to produce error estimates for the
     * rebined output data. Propagation of missing data (bad pixels)
     * is supported.
     * <p>
     * Note, if you will be rebining a sequence of input arrays and then
     * co-adding them into a single array, the alternative
     * astRebinSeq<X> functions
     * will in general be more efficient.
     * <p>
     * You should use a rebinning function which matches the numerical
     * type of the data you are processing by replacing <X> in
     * the generic function name astRebin<X> by an appropriate 1- or
     * 2-character type code. For example, if you are rebinning data
     * with type "float", you should use the function astRebinF (see
     * the "Data Type Codes" section below for the codes appropriate to
     * other numerical types).
     * <p>
     * Rebinning of the grid of input data is performed by transforming
     * the coordinates of the centre of each input grid element (or pixel)
     * into the coordinate system of the output grid. The input pixel
     * value is then divided up and assigned to the output pixels in the
     * neighbourhood of the central output coordinates. A choice of
     * schemes are provided for determining how each input pixel value is
     * divided up between the output pixels. In general, each output pixel
     * may be assigned values from more than one input pixel. All
     * contributions to a given output pixel are summed to produce the
     * final output pixel value. Output pixels can be set to the supplied
     * bad value if they receive contributions from an insufficient number
     * of input pixels. This is controlled by the
     * "wlim" parameter.
     * <p>
     * Input pixel coordinates are transformed into the coordinate
     * system of the output grid using the forward transformation of the
     * Mapping which is supplied. This means that geometrical features
     * in the input data are subjected to the Mapping's forward
     * transformation as they are transferred from the input to the
     * output grid.
     * <p>
     * In practice, transforming the coordinates of every pixel of a
     * large data grid can be time-consuming, especially if the Mapping
     * involves complicated functions, such as sky projections. To
     * improve performance, it is therefore possible to approximate
     * non-linear Mappings by a set of linear transformations which are
     * applied piece-wise to separate sub-regions of the data. This
     * approximation process is applied automatically by an adaptive
     * algorithm, under control of an accuracy criterion which
     * expresses the maximum tolerable geometrical distortion which may
     * be introduced, as a fraction of a pixel.
     * <p>
     * This algorithm first attempts to approximate the Mapping with a
     * linear transformation applied over the whole region of the
     * input grid which is being used. If this proves to be
     * insufficiently accurate, the input region is sub-divided into
     * two along its largest dimension and the process is repeated
     * within each of the resulting sub-regions. This process of
     * sub-division continues until a sufficiently good linear
     * approximation is found, or the region to which it is being
     * applied becomes too small (in which case the original Mapping is
     * used directly).
     * <h4>Pixel Spreading Schemes</h4>
     * The pixel spreading scheme specifies the Point Spread Function (PSF)
     * applied to each input pixel value as it is copied into the output
     * array. It can be thought of as the inverse of the sub-pixel
     * interpolation schemes used by the
     * astResample<X>
     * group of functions. That is, in a sub-pixel interpolation scheme the
     * kernel specifies the weight to assign to each input pixel when
     * forming the weighted mean of the input pixels, whereas the kernel in a
     * pixel spreading scheme specifies the fraction of the input data value
     * which is to be assigned to each output pixel. As for interpolation, the
     * choice of suitable pixel spreading scheme involves stricking a balance
     * between schemes which tend to degrade sharp features in the data by
     * smoothing them, and those which attempt to preserve sharp features but
     * which often tend to introduce unwanted artifacts. See the
     * astResample<X>
     * documentation for further discussion.
     * <p>
     * The binning algorithm used has the ability to introduce artifacts
     * not seen when using a resampling algorithm. Particularly, when
     * viewing the output image at high contrast, systems of curves lines
     * covering the entire image may be visible. These are caused by a
     * beating effect between the input pixel positions and the output pixels
     * position, and their nature and strength depend critically upon the
     * nature of the Mapping and the spreading function being used. In
     * general, the nearest neighbour spreading function demonstrates this
     * effect more clearly than the other functions, and for this reason
     * should be used with caution.
     * <p>
     * The following values (defined in the
     * "ast.h" header file)
     * may be assigned to the
     * "spread"
     * parameter. See the
     * astResample<X>
     * documentation for details of these schemes including the use of the
     * "fspread" and "params" parameters:
     * <p>
     * <br> - AST__NEAREST
     * <br> - AST__LINEAR
     * <br> - AST__SINC
     * <br> - AST__SINCSINC
     * <br> - AST__SINCCOS
     * <br> - AST__SINCGAUSS
     * <br> - AST__SOMBCOS
     * <p>
     * In addition, the following schemes can be used with
     * astRebin<X> but not with astResample<X>:
     * <p>
     * <br> - AST__GAUSS: This scheme uses a kernel of the form exp(-k*x*x), with k
     * a positive constant determined by the full-width at half-maximum (FWHM).
     * The FWHM should be supplied in units of output pixels by means of the
     * "params[1]"
     * value and should be at least 0.1. The
     * "params[0]"
     * value should be used to specify at what point the Gaussian is truncated
     * to zero. This should be given as a number of output pixels on either
     * side of the central output point in each dimension (the nearest integer
     * value is used).
     * <h4>Propagation of Missing Data</h4>
     * Instances of missing data (bad pixels) in the output grid are
     * identified by occurrences of the "badval" value in the "out"
     * array. These are produced if the sum of the weights of the
     * contributing input pixels is less than
     * "wlim".
     * <p>
     * An input pixel is considered bad (and is consequently ignored) if
     * its
     * data value is equal to "badval" and the AST__USEBAD flag is
     * set via the "flags" parameter.
     * <p>
     * In addition, associated output variance estimates (if
     * calculated) may be declared bad and flagged with the "badval"
     * value in the "out_var" array for similar reasons.
     * @param   wlim
     * Gives the required number of input pixel values which must contribute
     * to an output pixel in order for the output pixel value to be
     * considered valid. If the sum of the input pixel weights contributing
     * to an output pixel is less than the supplied
     * "wlim"
     * value, then the output pixel value is returned set to the
     * supplied bad value.
     * 
     * @param   ndim_in
     * The number of dimensions in the input grid. This should be at
     * least one.
     * 
     * @param   lbnd_in
     * Pointer to an array of integers, with "ndim_in" elements,
     * containing the coordinates of the centre of the first pixel
     * in the input grid along each dimension.
     * 
     * @param   ubnd_in
     * Pointer to an array of integers, with "ndim_in" elements,
     * containing the coordinates of the centre of the last pixel in
     * the input grid along each dimension.
     * <p>
     * Note that "lbnd_in" and "ubnd_in" together define the shape
     * and size of the input grid, its extent along a particular
     * (j'th) dimension being ubnd_in[j]-lbnd_in[j]+1 (assuming the
     * index "j" to be zero-based). They also define
     * the input grid's coordinate system, each pixel having unit
     * extent along each dimension with integral coordinate values
     * at its centre.
     * 
     * @param   in
     * Pointer to an array, with one element for each pixel in the
     * input grid, containing the input data to be rebined.  The
     * numerical type of this array should match the 1- or
     * 2-character type code appended to the function name (e.g. if
     * you are using astRebinF, the type of each array element
     * should be "float").
     * <p>
     * The storage order of data within this array should be such
     * that the index of the first grid dimension varies most
     * rapidly and that of the final dimension least rapidly
     * (i.e. Fortran array indexing is used).
     * 
     * @param   in_var
     * An optional pointer to a second array with the same size and
     * type as the "in" array. If given, this should contain a set
     * of non-negative values which represent estimates of the
     * statistical variance associated with each element of the "in"
     * array. If this array is supplied (together with the
     * corresponding "out_var" array), then estimates of the
     * variance of the rebined output data will be calculated.
     * <p>
     * If no input variance estimates are being provided, a NULL
     * pointer should be given.
     * 
     * @param   spread
     * a <code>Spreader</code> object which determines how each
     *             input data value is divided up amongst the corresponding
     *             output pixels
     *          
     * @param   usebad
     * if true, indicates that there may be bad
     *             pixels in the input array(s) which must be
     *             recognised by comparing with the value given for
     *             <code>badval</code> and propagated to the
     *             output array(s). If
     *             this flag is not set, all input values are treated
     *             literally and the <code>badval</code>
     *             value is only used for
     *             flagging output array values.
     *          
     * @param   tol
     * The maximum tolerable geometrical distortion which may be
     * introduced as a result of approximating non-linear Mappings
     * by a set of piece-wise linear transformations. This should be
     * expressed as a displacement in pixels in the output grid's
     * coordinate system.
     * <p>
     * If piece-wise linear approximation is not required, a value
     * of zero may be given. This will ensure that the Mapping is
     * used without any approximation, but may increase execution
     * time.
     * <p>
     * If the value is too high, discontinuities between the linear
     * approximations used in adjacent panel will be higher, and may
     * cause the edges of the panel to be visible when viewing the output
     * image at high contrast. If this is a problem, reduce the
     * tolerance value used.
     * 
     * @param   maxpix
     * A value which specifies an initial scale size (in pixels) for
     * the adaptive algorithm which approximates non-linear Mappings
     * with piece-wise linear transformations. Normally, this should
     * be a large value (larger than any dimension of the region of
     * the input grid being used). In this case, a first attempt to
     * approximate the Mapping by a linear transformation will be
     * made over the entire input region.
     * <p>
     * If a smaller value is used, the input region will first be
     * divided into sub-regions whose size does not exceed "maxpix"
     * pixels in any dimension. Only at this point will attempts at
     * approximation commence.
     * <p>
     * This value may occasionally be useful in preventing false
     * convergence of the adaptive algorithm in cases where the
     * Mapping appears approximately linear on large scales, but has
     * irregularities (e.g. holes) on smaller scales. A value of,
     * say, 50 to 100 pixels can also be employed as a safeguard in
     * general-purpose software, since the effect on performance is
     * minimal.
     * <p>
     * If too small a value is given, it will have the effect of
     * inhibiting linear approximation altogether (equivalent to
     * setting "tol" to zero). Although this may degrade
     * performance, accurate results will still be obtained.
     * 
     * @param   badval
     * This argument should have the same type as the elements of
     * the "in" array. It specifies the value used to flag missing
     * data (bad pixels) in the input and output arrays.
     * <p>
     * If the AST__USEBAD flag is set via the "flags" parameter,
     * then this value is used to test for bad pixels in the "in"
     * (and "in_var") array(s).
     * <p>
     * In all cases, this value is also used to flag any output
     * elements in the "out" (and "out_var") array(s) for which
     * rebined values could not be obtained (see the "Propagation
     * of Missing Data" section below for details of the
     * circumstances under which this may occur).
     * 
     * @param   ndim_out
     * The number of dimensions in the output grid. This should be
     * at least one. It need not necessarily be equal to the number
     * of dimensions in the input grid.
     * 
     * @param   lbnd_out
     * Pointer to an array of integers, with "ndim_out" elements,
     * containing the coordinates of the centre of the first pixel
     * in the output grid along each dimension.
     * 
     * @param   ubnd_out
     * Pointer to an array of integers, with "ndim_out" elements,
     * containing the coordinates of the centre of the last pixel in
     * the output grid along each dimension.
     * <p>
     * Note that "lbnd_out" and "ubnd_out" together define the
     * shape, size and coordinate system of the output grid in the
     * same way as "lbnd_in" and "ubnd_in" define the shape, size
     * and coordinate system of the input grid.
     * 
     * @param   lbnd
     * Pointer to an array of integers, with "ndim_in" elements,
     * containing the coordinates of the first pixel in the region
     * of the input grid which is to be included in the rebined output
     * array.
     * 
     * @param   ubnd
     * Pointer to an array of integers, with "ndim_in" elements,
     * containing the coordinates of the last pixel in the region of
     * the input grid which is to be included in the rebined output
     * array.
     * <p>
     * Note that "lbnd" and "ubnd" together define the shape and
     * position of a (hyper-)rectangular region of the input grid
     * which is to be included in the rebined output array. This region
     * should lie wholly within the extent of the input grid (as
     * defined by the "lbnd_in" and "ubnd_in" arrays). Regions of
     * the input grid lying outside this region will not be used.
     * 
     * @param   out
     * Pointer to an array, with one element for each pixel in the
     * output grid, in which the rebined data values will be
     * returned. The numerical type of this array should match that
     * of the "in" array, and the data storage order should be such
     * that the index of the first grid dimension varies most
     * rapidly and that of the final dimension least rapidly
     * (i.e. Fortran array indexing is used).
     * 
     * @param   out_var
     * An optional pointer to an array with the same type and size
     * as the "out" array. If given, this array will be used to
     * return variance estimates for the rebined data values. This
     * array will only be used if the "in_var" array has also been
     * supplied.
     * <p>
     * The output variance values will be calculated on the
     * assumption that errors on the input data values are
     * statistically independent and that their variance estimates
     * may simply be summed (with appropriate weighting factors)
     * when several input pixels contribute to an output data
     * value. If this assumption is not valid, then the output error
     * estimates may be biased. In addition, note that the
     * statistical errors on neighbouring output data values (as
     * well as the estimates of those errors) may often be
     * correlated, even if the above assumption about the input data
     * is correct, because of the pixel spreading schemes
     * employed.
     * <p>
     * If no output variance estimates are required, a NULL pointer
     * should be given.
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public void rebin( double wlim, int ndim_in, int[] lbnd_in, int[] ubnd_in, Object in, Object in_var, Mapping.Spreader spread, boolean usebad, double tol, int maxpix, Number badval, int ndim_out, int[] lbnd_out, int[] ubnd_out, int[] lbnd, int[] ubnd, Object out, Object out_var ){
        Class type = in.getClass().getComponentType();
        try {
            if ( type == int.class ) {
                rebinI( wlim, ndim_in, lbnd_in, ubnd_in, 
                        (int[]) in, (int[]) in_var,
                        spread, usebad, tol, maxpix, 
                        ((Integer) badval).intValue(), ndim_out, 
                        lbnd_out, ubnd_out, lbnd, ubnd,
                        (int[]) out, (int[]) out_var );
            }
            else if ( type == float.class ) {
                rebinF( wlim, ndim_in, lbnd_in, ubnd_in, 
                        (float[]) in, (float[]) in_var,
                        spread, usebad, tol, maxpix,
                        ((Float) badval).floatValue(), ndim_out,
                        lbnd_out, ubnd_out, lbnd, ubnd,
                        (float[]) out, (float[]) out_var );
            }
            else if ( type == double.class ) {
                rebinD( wlim, ndim_in, lbnd_in, ubnd_in,
                        (double[]) in, (double[]) in_var,
                        spread, usebad, tol, maxpix,
                        ((Double) badval).doubleValue(), ndim_out,
                        lbnd_out, ubnd_out, lbnd, ubnd,
                        (double[]) out, (double[]) out_var );
            }
            else {
                throw new ClassCastException( "Dummy class cast exception" );
            }
        }
        catch ( ClassCastException e ) {
            throw new IllegalArgumentException(
                "in, in_var, out and out_var must all be arrays of the same "
              + "primitive type, and badval a matching Number type" );
        }
    }
   /**
    * Rebinning method specific to int data.
    *
    * @see  #rebin
    */
   public native void rebinI(
      double wlim, int ndim_in, int[] lbnd_in, int[] ubnd_in,
      int[] in, int[] in_var,
      Mapping.Spreader spread, boolean usebad, double tol, int maxpix,
      int badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
      int[] lbnd, int[] ubnd,
      int[] out, int[] out_var );

   /**
    * Rebinning method specific to float data.
    *
    * @see  #rebin
    */
   public native void rebinF(
      double wlim, int ndim_in, int[] lbnd_in, int[] ubnd_in,
      float[] in, float[] in_var,
      Mapping.Spreader spread, boolean usebad, double tol, int maxpix,
      float badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
      int[] lbnd, int[] ubnd,
      float[] out, float[] out_var );

   /**
    * Rebinning method specific to double data.
    *
    * @see  #rebin
    */
   public native void rebinD(
      double wlim, int ndim_in, int[] lbnd_in, int[] ubnd_in,
      double[] in, double[] in_var,
      Mapping.Spreader spread, boolean usebad, double tol, int maxpix,
      double badval, int ndim_out, int[] lbnd_out, int[] ubnd_out,
      int[] lbnd, int[] ubnd,
      double[] out, double[] out_var );

    /** 
     * Transform 1-dimensional coordinates.   
     * This function applies a Mapping to transform the coordinates of
     * a set of points in one dimension.
     * <h4>Notes</h4>
     * <br> - The Mapping supplied must have the value 1 for both its Nin
     * and Nout attributes.
     * @param   npoint
     * The number of points to be transformed.
     * 
     * @param   xin
     * An array of "npoint" coordinate values for the input
     * (untransformed) points.
     * 
     * @param   forward
     * A non-zero value indicates that the Mapping's forward
     * coordinate transformation is to be applied, while a zero
     * value indicates that the inverse transformation should be
     * used.
     * 
     * @return  
     *          an array of npoint elements representing the transformed points
     *       
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double[] tran1( int npoint, double[] xin, boolean forward );

    /** 
     * Transform 2-dimensional coordinates.   
     * This function applies a Mapping to transform the coordinates of
     * a set of points in two dimensions.
     * <h4>Notes</h4>
     * <br> - The Mapping supplied must have the value 2 for both its Nin
     * and Nout attributes.
     * @param   npoint
     * The number of points to be transformed.
     * 
     * @param   xin
     * An array of "npoint" X-coordinate values for the input
     * (untransformed) points.
     * 
     * @param   yin
     * An array of "npoint" Y-coordinate values for the input
     * (untransformed) points.
     * 
     * @param   forward
     * A non-zero value indicates that the Mapping's forward
     * coordinate transformation is to be applied, while a zero
     * value indicates that the inverse transformation should be
     * used.
     * 
     * @return  
     *          a two-element array of arrays of doubles.  The first
     *          element is an <code>npoint</code>-element array giving
     *          the transformed X coordinates, and the second element
     *          is an <code>npoint</code>-element array giving the
     *          transformed Y coordinates.
     *       
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double[][] tran2( int npoint, double[] xin, double[] yin, boolean forward );

    /** 
     * Transform N-dimensional coordinates.   
     * This function applies a Mapping to transform the coordinates of
     * a set of points in an arbitrary number of dimensions. It is the
     * appropriate routine to use if the coordinates are not purely 1-
     * or 2-dimensional and are stored in a single array (which they
     * need not fill completely).
     * <p>
     * If the coordinates are not stored in a single array, then the
     * astTranP function might be more suitable.
     * <h4>Notes</h4>
     * <br> - If the forward coordinate transformation is being applied, the
     * Mapping supplied must have the value of "ncoord_in" for its Nin
     * attribute and the value of "ncoord_out" for its Nout attribute. If
     * the inverse transformation is being applied, these values should
     * be reversed.
     * @param   npoint
     * The number of points to be transformed.
     * 
     * @param   ncoord_in
     * The number of coordinates being supplied for each input point
     * (i.e. the number of dimensions of the space in which the
     * input points reside).
     * 
     * @param   in
     * The address of the first element in a 2-dimensional array of
     * shape "[ncoord_in][indim]",
     * containing the coordinates of the input (untransformed)
     * points. These should be stored such that the value of
     * coordinate number "coord" for input point number "point" is
     * found in element "in[coord][point]".
     * 
     * @param   forward
     * A non-zero value indicates that the Mapping's forward
     * coordinate transformation is to be applied, while a zero
     * value indicates that the inverse transformation should be
     * used.
     * 
     * @param   ncoord_out
     * The number of coordinates being generated by the Mapping for
     * each output point (i.e. the number of dimensions of the
     * space in which the output points reside). This need not be
     * the same as "ncoord_in".
     * 
     * @return  
     *          an array of <code>ncoord_out*npoint</code>
     *          coordinates representing the transformed points.
     *          Coordinate number <code>coord</code>
     *          for point <code>point</code> must be stored at
     *          <code>in[npoint*coord+point]</code>, that is the 
     *          all the coordinates for the first dimension are stored
     *          first, then all the coordinates for the second dimension ...
     *          This is the same order as for the <code>in</code> array.
     *       
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double[] tranN( int npoint, int ncoord_in, double[] in, boolean forward, int ncoord_out );

    /** 
     * Transform N-dimensional coordinates held in separate arrays.   
     * This function applies a Mapping to transform the coordinates of
     * a set of points in an arbitrary number of dimensions. It is the
     * appropriate routine to use if the coordinates are not purely 1-
     * or 2-dimensional and are stored in separate arrays, since each
     * coordinate array is located by supplying a separate pointer to
     * it.
     * <p>
     * If the coordinates are stored in a single (2-dimensional) array,
     * then the astTranN function might be more suitable.
     * <h4>Notes</h4>
     * <br> - If the forward coordinate transformation is being applied, the
     * Mapping supplied must have the value of "ncoord_in" for its Nin
     * attribute and the value of "ncoord_out" for its Nout
     * attribute. If the inverse transformation is being applied, these
     * values should be reversed.
     * <br> - This routine is not available in the Fortran 77 interface to
     * the AST library.
     * @param   npoint
     * The number of points to be transformed.
     * 
     * @param   ncoord_in
     * The number of coordinates being supplied for each input point
     * (i.e. the number of dimensions of the space in which the
     * input points reside).
     * 
     * @param   in
     * An <code>ncoord_in</code>-element array of 
     *             <code>npoint</code>-element arrays.  These give the 
     *             coordinates of the transformed points.
     *          
     * @param   forward
     * A non-zero value indicates that the Mapping's forward
     * coordinate transformation is to be applied, while a zero
     * value indicates that the inverse transformation should be
     * used.
     * 
     * @param   ncoord_out
     * The number of coordinates being generated by the Mapping for
     * each output point (i.e. the number of dimensions of the space
     * in which the output points reside). This need not be the same
     * as "ncoord_in".
     * 
     * @return  
     *          an <code>ncoord_out</code>-element array of 
     *          <code>npoint</code>-element arrays.
     *          These give the coordinates of the points to transform. 
     *       
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double[][] tranP( int npoint, int ncoord_in, double[][] in, boolean forward, int ncoord_out );

    /** 
     * Transform a grid of positions.   
     * This function uses the supplied Mapping to transforms a regular square
     * grid of points covering a specified box. It attempts to do this
     * quickly by first approximating the Mapping with a linear transformation
     * applied over the whole region of the input grid which is being used.
     * If this proves to be insufficiently accurate, the input region is
     * sub-divided into two along its largest dimension and the process is
     * repeated within each of the resulting sub-regions. This process of
     * sub-division continues until a sufficiently good linear approximation
     * is found, or the region to which it is being applied becomes too small
     * (in which case the original Mapping is used directly).
     * <h4>Notes</h4>
     * <br> - If the forward coordinate transformation is being applied, the
     * Mapping supplied must have the value of "ncoord_in" for its Nin
     * attribute and the value of "ncoord_out" for its Nout attribute. If
     * the inverse transformation is being applied, these values should
     * be reversed.
     * @param   ncoord_in
     * The number of coordinates being supplied for each box corner
     * (i.e. the number of dimensions of the space in which the
     * input points reside).
     * 
     * @param   lbnd
     * Pointer to an array of integers, with "ncoord_in" elements,
     * containing the coordinates of the centre of the first pixel
     * in the input grid along each dimension.
     * 
     * @param   ubnd
     * Pointer to an array of integers, with "ncoord_in" elements,
     * containing the coordinates of the centre of the last pixel in
     * the input grid along each dimension.
     * <p>
     * Note that "lbnd" and "ubnd" together define the shape
     * and size of the input grid, its extent along a particular
     * (j'th) dimension being ubnd[j]-lbnd[j]+1 (assuming the
     * index "j" to be zero-based). They also define
     * the input grid's coordinate system, each pixel having unit
     * extent along each dimension with integral coordinate values
     * at its centre.
     * 
     * @param   tol
     * The maximum tolerable geometrical distortion which may be
     * introduced as a result of approximating non-linear Mappings
     * by a set of piece-wise linear transformations. This should be
     * expressed as a displacement within the output coordinate system
     * of the Mapping.
     * <p>
     * If piece-wise linear approximation is not required, a value
     * of zero may be given. This will ensure that the Mapping is
     * used without any approximation, but may increase execution
     * time.
     * <p>
     * If the value is too high, discontinuities between the linear
     * approximations used in adjacent panel will be higher. If this
     * is a problem, reduce the tolerance value used.
     * 
     * @param   maxpix
     * A value which specifies an initial scale size (in input grid points)
     * for the adaptive algorithm which approximates non-linear Mappings
     * with piece-wise linear transformations. Normally, this should
     * be a large value (larger than any dimension of the region of
     * the input grid being used). In this case, a first attempt to
     * approximate the Mapping by a linear transformation will be
     * made over the entire input region.
     * <p>
     * If a smaller value is used, the input region will first be
     * divided into sub-regions whose size does not exceed "maxpix"
     * grid points in any dimension. Only at this point will attempts
     * at approximation commence.
     * <p>
     * This value may occasionally be useful in preventing false
     * convergence of the adaptive algorithm in cases where the
     * Mapping appears approximately linear on large scales, but has
     * irregularities (e.g. holes) on smaller scales. A value of,
     * say, 50 to 100 grid points can also be employed as a safeguard
     * in general-purpose software, since the effect on performance is
     * minimal.
     * <p>
     * If too small a value is given, it will have the effect of
     * inhibiting linear approximation altogether (equivalent to
     * setting "tol" to zero). Although this may degrade
     * performance, accurate results will still be obtained.
     * 
     * @param   forward
     * A non-zero value indicates that the Mapping's forward
     * coordinate transformation is to be applied, while a zero
     * value indicates that the inverse transformation should be
     * used.
     * 
     * @param   ncoord_out
     * The number of coordinates being generated by the Mapping for
     * each output point (i.e. the number of dimensions of the
     * space in which the output points reside). This need not be
     * the same as "ncoord_in".
     * 
     * @return  The address of the first element in a 2-dimensional array of
     * shape "[ncoord_out][outdim]", into
     * which the coordinates of the output (transformed) points will
     * be written. These will be stored such that the value of
     * coordinate number "coord" for output point number "point"
     * will be found in element "out[coord][point]".
     * The points are ordered such that the first axis of the input
     * grid changes most rapidly. For example, if the input grid is
     * 2-dimensional and extends from (2,-1) to (3,1), the output
     * points will be stored in the order (2,-1), (3, -1), (2,0), (3,0),
     * (2,1), (3,1).
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double[][] tranGrid( int ncoord_in, int[] lbnd, int[] ubnd, double tol, int maxpix, boolean forward, int ncoord_out );

    /** 
     * Calculate the rate of change of a Mapping output.   
     * This function
     * evaluates the rate of change of a specified output of the supplied
     * Mapping with respect to a specified input, at a specified input
     * position.
     * <p>
     * The result is estimated by interpolating the function using a
     * fourth order polynomial in the neighbourhood of the specified
     * position. The size of the neighbourhood used is chosen to minimise
     * the RMS residual per unit length between the interpolating
     * polynomial and the supplied Mapping function. This method produces
     * good accuracy but can involve evaluating the Mapping 100 or more
     * times.
     * <h4>Notes</h4>
     * <br> - A value of AST__BAD will be returned if this function is invoked
     * with the global error status set, or if it should fail for any
     * reason.
     * @param   at
     * The address of an
     * array holding the axis values at the position at which the rate
     * of change is to be evaluated. The number of elements in this
     * array should equal the number of inputs to the Mapping.
     * 
     * @param   ax1
     * The index of the Mapping output for which the rate of change is to
     * be found (output numbering starts at 1 for the first output).
     * 
     * @param   ax2
     * The index of the Mapping input which is to be varied in order to
     * find the rate of change (input numbering starts at 1 for the first
     * input).
     * 
     * @return  The rate of change of Mapping output "ax1" with respect to input
     * "ax2", evaluated at "at", or AST__BAD if the value cannot be
     * calculated.
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double rate( double[] at, int ax1, int ax2 );

    /** 
     * Obtain a linear approximation to a Mapping, if appropriate.   
     * This function tests the forward coordinate transformation
     * implemented by a Mapping over a given range of input coordinates. If
     * the transformation is found to be linear to a specified level of
     * accuracy, then an array of fit coefficients is returned. These
     * may be used to implement a linear approximation to the Mapping's
     * forward transformation within the specified range of output coordinates.
     * If the transformation is not sufficiently linear, no coefficients
     * are returned.
     * <h4>Notes</h4>
     * <br> - This function fits the Mapping's forward transformation. To fit
     * the inverse transformation, the Mapping should be inverted using
     * astInvert
     * before invoking this function.
     * <br> - A value of zero
     * will be returned if this function is invoked
     * with the global error status set, or if it should fail for any
     * reason.
     * <p>
     *       If this mapping is not linear to the given tolerance, <tt>null</tt>
     *       will be returned.
     *    
     * @param   lbnd
     * Pointer to an array of doubles
     * containing the lower bounds of a box defined within the input
     * coordinate system of the Mapping. The number of elements in this
     * array should equal the value of the Mapping's Nin attribute. This
     * box should specify the region over which linearity is required.
     * 
     * @param   ubnd
     * Pointer to an array of doubles
     * containing the upper bounds of the box specifying the region over
     * which linearity is required.
     * 
     * @param   tol
     * The maximum permitted deviation from linearity, expressed as
     * a positive Cartesian displacement in the output coordinate
     * space of the Mapping. If a linear fit to the forward
     * transformation of the Mapping deviates from the true transformation
     * by more than this amount at any point which is tested, then no fit
     * coefficients will be returned.
     * 
     * @return  Pointer to an array of doubles
     * in which to return the co-efficients of the linear
     * approximation to the specified transformation. This array should
     * have at least "( Nin + 1 ) * Nout", elements. The first Nout elements
     * hold the constant offsets for the transformation outputs. The
     * remaining elements hold the gradients. So if the Mapping has 2 inputs
     * and 3 outputs the linear approximation to the forward transformation
     * is:
     * <p>
     *    X_out = fit[0] + fit[3]*X_in + fit[4]*Y_in
     * <p>
     *    Y_out = fit[1] + fit[5]*X_in + fit[6]*Y_in
     * <p>
     *    Z_out = fit[2] + fit[7]*X_in + fit[8]*Y_in
     * <p>
     * 
     * @throws  AstException  if an error occurred in the AST library
     */
    public native double[] linearApprox( double[] lbnd, double[] ubnd, double tol );

    /**
     * Get 
     * mapping inversion flag.  
     * This attribute controls which one of a Mapping's two possible
     * coordinate transformations is considered the "forward"
     * transformation (the other being the "inverse"
     * transformation). If the attribute value is zero (the default),
     * the Mapping's behaviour will be the same as when it was first
     * created. However, if it is non-zero, its two transformations
     * will be inter-changed, so that the Mapping displays the inverse
     * of its original behaviour.
     * <p>
     * Inverting the boolean sense of the Invert attribute will cause
     * the values of a Mapping's Nin and Nout attributes to be
     * interchanged. The values of its TranForward and TranInverse
     * attributes will also be interchanged. This operation may be
     * performed with the astInvert function.
     * 
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>UnitMap</dt><dd>
     *    The value of the Invert attribute has no effect on the
     *    behaviour of a UnitMap.
     * <dt>FrameSet</dt><dd>
     *    Inverting the boolean sense of the Invert attribute for a
     *    FrameSet will cause its base and current Frames (and its Base
     *    and Current attributes) to be interchanged. This, in turn,
     *    may affect other properties and attributes of the FrameSet
     *    (such as Nin, Nout, Naxes, TranForward, TranInverse,
     *    etc.). The Invert attribute of a FrameSet is not itself
     *    affected by selecting a new base or current Frame.
     * </dl>
     * 
     *
     * @return  this object's Invert attribute
     */
    public boolean getInvert() {
        return getB( "Invert" );
    }

    /**
     * Set 
     * mapping inversion flag.  
     * This attribute controls which one of a Mapping's two possible
     * coordinate transformations is considered the "forward"
     * transformation (the other being the "inverse"
     * transformation). If the attribute value is zero (the default),
     * the Mapping's behaviour will be the same as when it was first
     * created. However, if it is non-zero, its two transformations
     * will be inter-changed, so that the Mapping displays the inverse
     * of its original behaviour.
     * <p>
     * Inverting the boolean sense of the Invert attribute will cause
     * the values of a Mapping's Nin and Nout attributes to be
     * interchanged. The values of its TranForward and TranInverse
     * attributes will also be interchanged. This operation may be
     * performed with the astInvert function.
     * 
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>UnitMap</dt><dd>
     *    The value of the Invert attribute has no effect on the
     *    behaviour of a UnitMap.
     * <dt>FrameSet</dt><dd>
     *    Inverting the boolean sense of the Invert attribute for a
     *    FrameSet will cause its base and current Frames (and its Base
     *    and Current attributes) to be interchanged. This, in turn,
     *    may affect other properties and attributes of the FrameSet
     *    (such as Nin, Nout, Naxes, TranForward, TranInverse,
     *    etc.). The Invert attribute of a FrameSet is not itself
     *    affected by selecting a new base or current Frame.
     * </dl>
     * 
     *
     * @param  invert   the Invert attribute of this object
     */
    public void setInvert( boolean invert ) {
       setB( "Invert", invert );
    }

    /**
     * Get 
     * number of input coordinates for a Mapping.  
     * This attribute gives the number of coordinate values required to
     * specify an input point for a Mapping (i.e. the number of
     * dimensions of the space in which the Mapping's input points
     * reside).
     * 
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>CmpMap</dt><dd>
     *    If a CmpMap's component Mappings are joined in series, then
     *    its Nin attribute is equal to the Nin attribute of the first
     *    component (or to the Nout attribute of the second component
     *    if the the CmpMap's Invert attribute is non-zero).
     * <p>
     *    If a CmpMap's component Mappings are joined in parallel, then
     *    its Nin attribute is given by the sum of the Nin attributes
     *    of each component (or to the sum of their Nout attributes if
     *    the CmpMap's Invert attribute is non-zero).
     * <dt>Frame</dt><dd>
     *    The Nin attribute for a Frame is always equal to the number
     *    of Frame axes (Naxes attribute).
     * <dt>FrameSet</dt><dd>
     *    The Nin attribute of a FrameSet is equal to the number of
     *    axes (Naxes attribute) of its base Frame (as specified by the
     *    FrameSet's Base attribute). The Nin attribute value may
     *    therefore change if a new base Frame is selected.
     * </dl>
     * 
     *
     * @return  this object's Nin attribute
     */
    public int getNin() {
        return getI( "Nin" );
    }

    /**
     * Get 
     * number of output coordinates for a Mapping.  
     * This attribute gives the number of coordinate values generated
     * by a Mapping to specify each output point (i.e. the number of
     * dimensions of the space in which the Mapping's output points
     * reside).
     * 
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>CmpMap</dt><dd>
     *    If a CmpMap's component Mappings are joined in series, then
     *    its Nout attribute is equal to the Nout attribute of the
     *    second component (or to the Nin attribute of the first
     *    component if the the CmpMap's Invert attribute is non-zero).
     * <p>
     *    If a CmpMap's component Mappings are joined in parallel, then
     *    its Nout attribute is given by the sum of the Nout attributes
     *    of each component (or to the sum of their Nin attributes if
     *    the CmpMap's Invert attribute is non-zero).
     * <dt>Frame</dt><dd>
     *    The Nout attribute for a Frame is always equal to the number
     *    of Frame axes (Naxes attribute).
     * <dt>FrameSet</dt><dd>
     *    The Nout attribute of a FrameSet is equal to the number of
     *    FrameSet axes (Naxes attribute) which, in turn, is equal to
     *    the Naxes attribute of the FrameSet's current Frame (as
     *    specified by the Current attribute). The Nout attribute value
     *    may therefore change if a new current Frame is selected.
     * </dl>
     * 
     *
     * @return  this object's Nout attribute
     */
    public int getNout() {
        return getI( "Nout" );
    }

    /**
     * Get 
     * report transformed coordinates.  
     * This attribute controls whether coordinate values are reported
     * whenever a Mapping is used to transform a set of points. If its
     * value is zero (the default), no report is made. However, if it
     * is non-zero, the coordinates of each point are reported (both
     * before and after transformation) by writing them to standard
     * output.
     * <p>
     * This attribute is provided as an aid to debugging, and to avoid
     * having to report values explicitly in simple programs.
     * <h4>Notes</h4>
     * <br> - Unlike most other attributes, the value of the Report
     * attribute is not transferred when a Mapping is copied. Instead,
     * its value is undefined (and therefore defaults to zero) in any
     * copy. Similarly, it becomes undefined in any external
     * representation of a Mapping produced by the astWrite function.
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>CmpMap</dt><dd>
     *    When applied to a compound Mapping (CmpMap), only the Report
     *    attribute of the CmpMap, and not those of its component
     *    Mappings, is used.  Coordinate information is never reported
     *    for the component Mappings individually, only for the
     *    complete CmpMap.
     * <dt>Frame</dt><dd>
     *    When applied to any Frame, the formatting capabilities of the
     *    Frame (as provided by the astFormat function) will be used to
     *    format the reported coordinates.
     * <dt>FrameSet</dt><dd>
     *    When applied to any FrameSet, the formatting capabilities of
     *    the base and current Frames will be used (as above) to
     *    individually format the input and output coordinates, as
     *    appropriate. The Report attribute of a FrameSet is not itself
     *    affected by selecting a new base or current Frame, but the
     *    resulting formatting capabilities may be.
     * <p>
     * </dl>
     * 
     *
     * @return  this object's Report attribute
     */
    public boolean getReport() {
        return getB( "Report" );
    }

    /**
     * Set 
     * report transformed coordinates.  
     * This attribute controls whether coordinate values are reported
     * whenever a Mapping is used to transform a set of points. If its
     * value is zero (the default), no report is made. However, if it
     * is non-zero, the coordinates of each point are reported (both
     * before and after transformation) by writing them to standard
     * output.
     * <p>
     * This attribute is provided as an aid to debugging, and to avoid
     * having to report values explicitly in simple programs.
     * <h4>Notes</h4>
     * <br> - Unlike most other attributes, the value of the Report
     * attribute is not transferred when a Mapping is copied. Instead,
     * its value is undefined (and therefore defaults to zero) in any
     * copy. Similarly, it becomes undefined in any external
     * representation of a Mapping produced by the astWrite function.
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>CmpMap</dt><dd>
     *    When applied to a compound Mapping (CmpMap), only the Report
     *    attribute of the CmpMap, and not those of its component
     *    Mappings, is used.  Coordinate information is never reported
     *    for the component Mappings individually, only for the
     *    complete CmpMap.
     * <dt>Frame</dt><dd>
     *    When applied to any Frame, the formatting capabilities of the
     *    Frame (as provided by the astFormat function) will be used to
     *    format the reported coordinates.
     * <dt>FrameSet</dt><dd>
     *    When applied to any FrameSet, the formatting capabilities of
     *    the base and current Frames will be used (as above) to
     *    individually format the input and output coordinates, as
     *    appropriate. The Report attribute of a FrameSet is not itself
     *    affected by selecting a new base or current Frame, but the
     *    resulting formatting capabilities may be.
     * <p>
     * </dl>
     * 
     *
     * @param  report   the Report attribute of this object
     */
    public void setReport( boolean report ) {
       setB( "Report", report );
    }

    /**
     * Get 
     * forward transformation defined.  
     * This attribute indicates whether a Mapping is able to transform
     * coordinates in the "forward" direction (i.e. converting input
     * coordinates into output coordinates). If this attribute is
     * non-zero, the forward transformation is available. Otherwise, it
     * is not.
     * <h4>Notes</h4>
     * <br> - An error will result if a Mapping with a TranForward value of
     * zero is used to transform coordinates in the forward direction.
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>CmpMap</dt><dd>
     *    The TranForward attribute value for a CmpMap is given by the
     *    boolean AND of the value for each component Mapping.
     * <dt>FrameSet</dt><dd>
     *    The TranForward attribute of a FrameSet applies to the
     *    transformation which converts between the FrameSet's base
     *    Frame and its current Frame (as specified by the Base and
     *    Current attributes). This value is given by the boolean AND
     *    of the TranForward values which apply to each of the
     *    individual sub-Mappings required to perform this conversion.
     *    The TranForward attribute value for a FrameSet may therefore
     *    change if a new Base or Current Frame is selected.
     * <p>
     * </dl>
     * 
     *
     * @return  this object's TranForward attribute
     */
    public boolean getTranForward() {
        return getB( "TranForward" );
    }

    /**
     * Get 
     * inverse transformation defined.  
     * This attribute indicates whether a Mapping is able to transform
     * coordinates in the "inverse" direction (i.e. converting output
     * coordinates back into input coordinates). If this attribute is
     * non-zero, the inverse transformation is available. Otherwise, it
     * is not.
     * <h4>Notes</h4>
     * <br> - An error will result if a Mapping with a TranInverse value of
     * zero is used to transform coordinates in the inverse direction.
     * <h4>Class Applicability</h4>
     * <dl>
     * <dt>Mapping</dt><dd>
     *    All Mappings have this attribute.
     * <dt>CmpMap</dt><dd>
     *    The TranInverse attribute value for a CmpMap is given by the
     *    boolean AND of the value for each component Mapping.
     * <dt>FrameSet</dt><dd>
     *    The TranInverse attribute of a FrameSet applies to the
     *    transformation which converts between the FrameSet's current
     *    Frame and its base Frame (as specified by the Current and
     *    Base attributes). This value is given by the boolean AND of
     *    the TranInverse values which apply to each of the individual
     *    sub-Mappings required to perform this conversion.
     *    The TranInverse attribute value for a FrameSet may therefore
     *    change if a new Base or Current Frame is selected.
     * <p>
     * </dl>
     * 
     *
     * @return  this object's TranInverse attribute
     */
    public boolean getTranInverse() {
        return getB( "TranInverse" );
    }


    /*
     * Inner classes.
     */

    /**
     * Controls the interpolation scheme used by <code>Mapping</code>'s
     * resampling methods.  This class has no public constructors, but
     * provides static factory methods which generate <code>Interpolator</code>
     * objects that can be passed to the <code>resample*</code> methods.
     * There are a number of standard schemes, and users may supply their
     * own by implementing the {@link Ukern1Calculator} or
     * {@link UinterpCalculator} interfaces.
     */
    public static class Interpolator {

        /*
         * Private fields written by the factory methods and read by
         * AstMapping native code.
         */
        private int scheme;
        private Ukern1Calculator ukern1er;
        private UinterpCalculator uinterper;

        /* Used as a buffer by native code as well as resampleX documented
         * use. */
        private double params[];

        /*
         * Values of resampling scheme identifiers in AST C library.
         */
        private static final int AST__NEAREST =
                getAstConstantI( "AST__NEAREST" );
        private static final int AST__LINEAR =
                getAstConstantI( "AST__LINEAR" );
        private static final int AST__SINC =
                getAstConstantI( "AST__SINC" );
        private static final int AST__SINCSINC =
                getAstConstantI( "AST__SINCSINC" );
        private static final int AST__SINCCOS =
                getAstConstantI( "AST__SINCCOS" );
        private static final int AST__SOMB =
                getAstConstantI( "AST__SOMB" );
        private static final int AST__SOMBCOS =
                getAstConstantI( "AST__SOMBCOS" );
        private static final int AST__SINCGAUSS =
                getAstConstantI( "AST__SINCGAUSS" );
        private static final int AST__BLOCKAVE =
                getAstConstantI( "AST__BLOCKAVE" );
        private static final int AST__UKERN1 =
                getAstConstantI( "AST__UKERN1" );
        private static final int AST__UINTERP =
                getAstConstantI( "AST__UINTERP" );

        /*
         * Sole private constructor.
         */
        private Interpolator( int scheme, double[] params ) {
            this.scheme = scheme;

            /* Ensure that the params array has some spare space, since
             * it is used by native code to store one or two pointers
             * as well as its documented resampleX use.  8 is plenty. */
            this.params = new double[ 8 ];
            if ( params != null ) {
                for ( int i = 0; i < params.length; i++ ) {
                    this.params[ i ] = params[ i ];
                }
            }
        }

        /*
         * Public static methods which return the various kinds of 
         * interpolators.
         */

        /**
         * Returns a resampling interpolator which does
         * nearest-neighbour 'interpolation'.
         *
         * @return  a nearest-neighbour resampling Interpolator
         */
        public static Interpolator nearest() {
            return new Interpolator( AST__NEAREST, null );
        }

        /**
         * Returns a resampling interpolator which does linear interpolation.
         *
         * @return  a linear resampling Interpolator
         */
        public static Interpolator linear() {
            return new Interpolator( AST__LINEAR, null );
        }

        /**
         * Returns a resampling interpolator which uses a
         * <code>sinc(pi*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @return  a sinc-type resampling Interpolator
         */
        public static Interpolator sinc( int npix ) {
            return new Interpolator( AST__SINC,
                                     new double[] { (double) npix } );
        }

        /**
         * Returns a resampling interpolator which uses a
         * <code>sinc(pi*x).sinc(k*pi*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @param  width  the number of pixels at which the envelope goes
         *                to zero.  Should be at least 1.0.
         * @return  a sinc-sinc-type resampling Interpolator
         */
        public static Interpolator sincSinc( int npix, double width ) {
            return new Interpolator( AST__SINCSINC,
                                     new double[] { (double) npix, width } );
        }

        /**
         * Returns a resampling interpolator which uses a
         * <code>sinc(pi*x).cos(k*pi*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @param  width  the number of pixels at which the envelope goes
         *                to zero.  Should be at least 1.0.
         * @return  a sinc-cos-type resampling Interpolator
         */
        public static Interpolator sincCos( int npix, double width ) {
            return new Interpolator( AST__SINCCOS,
                                     new double[] { (double) npix, width } );
        }

        /**
         * Returns a resampling interpolator which uses a
         * <code>somb(pi*x)</code> 1-dimensional kernel 
         * (a "sombrero" function).
         * <code>x</code> is the pixel offset from the interpolation point
         * and <code>somb(z)=2*1(z)/z</code> (J1 is a Bessel function
         * of the first kind of order 1).
         *
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @return  a somb-type resampling Interpolator
         */
        public static Interpolator somb( int npix ) {
            return new Interpolator( AST__SOMB,
                                     new double[] { (double) npix } );
        }

        /**
         * Returns a resampling interpolator which uses a
         * <code>somb(pi*x).cos(k*pi*x)</code> 1-dimensional kernel.
         * <code>k</code> is a constant, out to the point where
         * <code>cos(k*pi*x) goes to zero, and zero beyond,
         * and <code>somb(z)=2*1(z)/z</code> (J1 is a Bessel function
         * of the first kind of order 1).
         *
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @param  width  the number of pixels at which the envelope goes
         *                to zero.  Should be at least 1.0.
         * @return  a sinc-cos-type resampling Interpolator
         */
        public static Interpolator sombCos( int npix, double width ) {
            return new Interpolator( AST__SOMBCOS,
                                     new double[] { (double) npix, width } );
        }

        /**
         * Returns a resampling interpolator which uses a
         * <code>sinc(pi*x).exp(-k*x*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @param  fwhm   the full width at half maximum of the Gaussian
         *                envelope.  Should be at least 0.1.
         * @return a sinc-Gauss-type resampling Interpolator
         */
        public static Interpolator sincGauss( int npix, double fwhm ) {
            return new Interpolator( AST__SINCGAUSS,
                                     new double[] { (double) npix, fwhm } );
        }

        /**
         * Returns a block averaging resampling interpolator.
         *
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         * @return  a block averaging resampling Interpolator
         */
        public static Interpolator blockAve( int npix ) {
            return new Interpolator( AST__BLOCKAVE,
                                     new double[] { (double) npix } );
        }

        /**
         * Returns a resampling interpolator which uses a given user-defined
         * 1-dimensional kernel.
         *
         * @param   ukern1er  a Ukern1Calculator object which defines a 
         *                    1-dimensional kernel function
         * @param   npix  the number of pixels to contribute to the 
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @return  a user 1-d kernel resampling Interpolator
         */
        public static Interpolator ukern1( Ukern1Calculator ukern1er, 
                                           int npix ) {
            Interpolator interp =
                new Interpolator( AST__UKERN1, new double[] { (double) npix } );
            interp.ukern1er = ukern1er;
            return interp;
        }

        /**
         * Returns a resampling interpolator which uses a given user-defined
         * generic resampling function.
         *
         * @param uinterper  a UinterpCalculator object which defines a generic
         *          resampling function
         * @return  a generic user-defined resampling Interpolator
         */
        public static Interpolator uinterp( UinterpCalculator uinterper ) {
            Interpolator interp = new Interpolator( AST__UINTERP, null );
            interp.uinterper = uinterper;
            return interp;
        }
    }

    /**
     * Controls the spreading scheme used by <code>Mapping</code>'s
     * rebinning methods.  This class has no public constructors,
     * but provides static factory methods which generate <code>Spreader</code>
     * objects that can be passed to the <code>rebin*</code> methods.
     */
    public static class Spreader {

        /*
         * Private fields written by the factory methods and read by
         * AstMapping native code.
         */
        private int scheme_;

        /*
         * Used as a buffer by native code as well sa rebinX documented use.
         */
        private double[] params_;

        /*
         * Values of spreading scheme identifiers in C library.
         */
        private static final int AST__NEAREST =
                getAstConstantI( "AST__NEAREST" );
        private static final int AST__LINEAR =
                getAstConstantI( "AST__LINEAR" );
        private static final int AST__SINC =
                getAstConstantI( "AST__SINC" );
        private static final int AST__SINCSINC =
                getAstConstantI( "AST__SINCSINC" );
        private static final int AST__SINCCOS =
                getAstConstantI( "AST__SINCCOS" );
        private static final int AST__SINCGAUSS =
                getAstConstantI( "AST__SINCGAUSS" );
        private static final int AST__GAUSS =
                getAstConstantI( "AST__GAUSS" );

        /**
         * Sole private constructor.
         */
        private Spreader( int scheme, double[] params ) {
            scheme_ = scheme;
            params_ = params;
        }

        /*
         * Public static methods which return the various kinds of spreaders.
         */

        /**
         * Returns a resampling spreader which samples from the
         * nearest neighbour.
         *
         * @return  a nearest-neighbour resampling Spreader
         */
        public static Spreader nearest() {
            return new Spreader( AST__NEAREST, null );
        }

        /**
         * Returns a resampling spreader which samples using 
         * linear interpolation.
         *
         * @return  a linear interpolation resampling Spreader
         */
        public static Spreader linear() {
            return new Spreader( AST__LINEAR, null );
        }

        /**
         * Returns a resampling spreader which uses a
         * <code>sinc(pi*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @return  a sinc-type resampling Spreader
         */
        public static Spreader sinc( int npix ) {
            return new Spreader( AST__SINC,
                                 new double[] { (double) npix } );
        }

        /**
         * Returns a resampling spreader which uses a
         * <code>sinc(pi*x).sinc(k*pi*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @param  width  the number of pixels at which the envelope goes
         *                to zero.  Should be at least 1.0.
         * @return  a sinc-sinc-type resampling Spreader
         */
        public static Spreader sincSinc( int npix, double width ) {
            return new Spreader( AST__SINCSINC,
                                 new double[] { (double) npix, width } );
        }

        /**
         * Returns a resampling spreader which uses a
         * <code>sinc(pi*x).cos(k*pi*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @param  width  the number of pixels at which the envelope goes
         *                to zero.  Should be at least 1.0.
         * @return  a sinc-cos-type resampling Spreader
         */
        public static Spreader sincCos( int npix, double width ) {
            return new Spreader( AST__SINCCOS,
                                 new double[] { (double) npix, width } );
        }

        /**
         * Returns a resampling spreader which uses a
         * <code>sinc(pi*x).exp(-k*x*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         *                Execution time increases rapidly with this number.
         *                Typically, a value of 2 is appropriate and the
         *                minimum value used will be 1.  A value of zero
         *                or less may be given to indicate that a suitable
         *                number of pixels should be calculated automatically.
         * @param  fwhm   the full width at half maximum of the Gaussian
         *                envelope.  Should be at least 0.1.
         * @return a sinc-Gauss-type resampling Spreader
         */
        public static Spreader sincGauss( int npix, double fwhm ) {
            return new Spreader( AST__SINCGAUSS,
                                 new double[] { (double) npix, fwhm } );
        }

        /**
         * Returns a resampling spreader which uses a
         * <code>exp(-k*x*x)</code> 1-dimensional kernel.
         *
         * @param   npix  the number of pixels to contribute to the
         *                interpolated result on either side of the
         *                interpolation point in each dimension.
         * @param   fwhm  the full width at half maximum of the Gaussian
         *                envelope.  Should be at least 0.1.
         * @return  a Gauss-type resampling Spreader
         */
        public static Spreader gauss( int npix, double fwhm ) {
            return new Spreader( AST__GAUSS,
                                 new double[] { (double) npix, fwhm } );
        }
    }

}

