/*
 * Copyright (C) 2003 Central Laboratory of the Research Councils
 *
 *  History:
 *     28-SEP-2000 (Peter W. Draper):
 *       Original version.
 */
package uk.ac.starlink.splat.data;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import nom.tam.fits.BasicHDU;
import nom.tam.fits.BinaryTable;
import nom.tam.fits.BinaryTableHDU;
import nom.tam.fits.Fits;
import nom.tam.fits.HeaderCard;
import nom.tam.util.BufferedDataOutputStream;
import nom.tam.util.Cursor;

import uk.ac.starlink.splat.iface.GlobalSpecPlotList;
import uk.ac.starlink.splat.iface.SpectrumIO;
import uk.ac.starlink.splat.iface.SpectrumIO.SourceType;
import uk.ac.starlink.splat.util.Utilities;

/**
 * SpecList is a singleton object that contains references to all the
 * known spectra. The SpecList object should be updated with any new spectra
 * when they are created and also updated whenever a spectrum is
 * destroyed. Normally this task will be performed using the 
 * {@link GlobalSpecPlotList} object.
 *
 * @version $Id$
 * @author Peter W. Draper
 *
 * @see SpecDataFactory
 * @see "The Singleton Design Pattern"
 *
 */
public class SpecList implements Serializable
{
    
	/**
	 * File format enumeration for saving the spectra list
	 */
	public static enum FileFormat{
    	
    	STK("stk", "STK files", 0),
    	FITS("fits", "FITS files", 1);
    	
    	private String fileExtension;
    	private String description;
    	private int listIndex;
    	
    	private FileFormat(String fileExtension, String description, int listIndex) {
    		this.fileExtension = fileExtension;
    		this.description = description;
    		this.listIndex = listIndex;
    	}

		public String getFileExtension() {
			return fileExtension;
		}
		
		public String getDescription() {
			return description;
		}
		
		public int getListIndex() {
			return listIndex;
		}
    	
		public FileFormat getByExtension(String extension) {
			if (extension != null) {
				for (FileFormat ff : FileFormat.values()) {
					if (extension.equalsIgnoreCase(ff.getFileExtension()))
						return ff;
				}
			}
			return null;
		}
    }
	
	/**
     *  Create the single class instance.
     */
    private static final SpecList instance = new SpecList();

    /**
     *  Hide the constructor from use.
     */
    private SpecList() {}

    /**
     *  Return reference to the only allowed instance of this class.
     */
    public static SpecList getInstance()
    {
        return instance;
    }

    /**
     *  ArrayList of references to spectra
     */
    protected ArrayList spectra = new ArrayList();
    
    /**
     * Map of spectra and the source, from which the spectra came from
     */
    protected Map<SpecData, SourceType> sources = new HashMap<SpecData, SourceType>();

    /**
     *  Serialization version ID string (generated by serialver on
     *  original star.jspec.data.SpecList class).
     */
    static final long serialVersionUID = 6942346493134803694L;

    /**
     *  Get the number of spectra.
     */
    public int specCount()
    {
        return spectra.size();
    }

    /**
     *  Add a spectrum.
     */
    public int add( SpecData spectrum, SourceType sourceType )
    {
        spectra.add( spectrum );
        sources.put(spectrum, sourceType);
        return spectra.size() - 1;
    }
    
    /**
     *  Add a spectrum with unknown source type.
     */
    public int add(SpecData spectrum) {
    	return add(spectrum, SourceType.UNDEFINED);
    }

    /**
     *  Add or replace a spectrum.
     */
    public int add( int index, SpecData spectrum, SourceType sourceType )
    {
        if ( index < specCount() ) {
            spectra.set( index, spectrum );
            return index;
        } 
        else {
            return add( spectrum, sourceType );
        }
    }
    
    /**
     *  Add a spectrum with an unknown source or replace a spectrum.
     */
    public int add( int index, SpecData spectrum )
    {
    	return add( index, spectrum, SourceType.UNDEFINED );
    }

    /**
     *  Remove a spectrum.
     */
    public int remove( SpecData spectrum )
    {
        int index = spectra.indexOf( spectrum );
        if ( index != -1 ) {
           if (sources.containsKey(spectrum))
        	   sources.remove(spectrum);
           
        	spectra.remove( index );
        }
        return index;
    }

    /**
     *  Remove a spectrum.
     */
    public void remove( int index )
    {
        if ( index < specCount() ) {
            SpecData spectrum = (SpecData) spectra.get(index);
            if (sources.containsKey(spectrum))
            	sources.remove(spectrum);
            
        	spectra.remove( index );
        }
    }

    /**
     *  Get a spectrum by index.
     */
    public SpecData get( int index )
    {
        if ( index < specCount() ) {
            return (SpecData)spectra.get( index );
        }
        return null;
    }

    /**
     *  Get the index of a spectrum.
     */
    public int indexOf( SpecData spectrum )
    {
        return spectra.indexOf( spectrum );
    }

    /**
     *  Return the index of a spectrum with the given short
     *  name. Returns -1 if unsuccessful.
     */
    public int indexOf( String shortName )
    {
        for ( int i = 0; i < spectra.size(); i++ ) {
            if ( getShortName( i ).equals( shortName ) ) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 
     * @param spectrum
     * @return source type from which the spectra came from
     */
    public SourceType getSourceType(SpecData spectrum) {
    	return sources.get(spectrum);
    }
    
    /**
     *  Return the full (i.e.<!-- --> disk file) name of a spectrum.
     */
    public String getFullName( int index )
    {
        if ( index < specCount() ) {
            return ((SpecData)spectra.get( index )).getFullName();
        }
        return null;
    }

    /**
     *  Return the symbolic name of a spectrum.
     */
    public String getShortName( int index )
    {
        if ( index < specCount() ) {
            return ((SpecData)spectra.get( index )).getShortName();
        }
        return null;
    }

    /**
     *  Set the symbolic name of a spectrum.
     */
    public void setShortName( int index, String name )
    {
        if ( index < specCount() ) {
            ((SpecData)spectra.get( index )).setShortName( name );
        }
    }

    /**
     *  Set the name of a spectrum.
     */
    public void setShortName( SpecData spectrum, String name )
    {
        spectrum.setShortName( name );
    }

    /**
     *  See if a spectrum is already present using its specification
     * (i.e.<!-- --> file name). Returns the index if found and -1 otherwise.
     */
    public int known( String fileName )
    {
        for ( int i = 0; i < spectra.size(); i++ ) {
            if ( ((SpecData)spectra.get(i)).getFullName().equals(fileName) ) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Save current state to a file as a serialised stream. The stream
     * is Gzipped to save space and should be restored using the
     * readStack method (which appends the previous state).
     */
    public void writeStack( String fileName ) {
    	writeStack(SpecList.FileFormat.STK, fileName);
    }
    
    /**
     * Save current state to a file as a serialised stream. The stream
     * is Gzipped to save space and should be restored using the
     * readStack method (which appends the previous state).
     * 
     * @param fileFormat Format of the result file
     */
	public void writeStack( SpecList.FileFormat fileFormat, String fileName )
    {
		// TODO make it protected somewhere else...
        SpecDataFactory specDataFactory = SpecDataFactory.getInstance();
		//int saveUsertypeIndex = SpecDataFactory.DEFAULT;
		
		switch (fileFormat) {
        	case FITS:
        		try {
        			OutputStream file = new FileOutputStream( fileName );
                    OutputStream buffer = new GZIPOutputStream( file );
                    ObjectOutputStream out = new ObjectOutputStream( buffer );
                    out.writeObject( this );
                    out.close();
                    
                    Fits fitsref = new Fits();
                    
                    for (int i = 0; i < spectra.size(); i++) {
                    	synchronized(spectra.get(i)) {
                    		SpecData target =
                                    specDataFactory.getClone( (SpecData)spectra.get(i), "", SpecDataFactory.FITS,
                                       "fits" );
                    		BasicHDU extHdu = ((FITSSpecDataImpl)(target.getSpecDataImpl())).makeHDU(false);
                    		
                    		Cursor iter = extHdu.getHeader().iterator();
                            iter.setKey( "OBJECT" );
                            if ( iter.hasNext() ) {
                                iter.next();
                            }
                            
                    		iter.add( "GNRTR", new HeaderCard( "GNRTR", Utilities.getReleaseName(),
                    				"SPLAT's list of spectra item" ) );
                    		
                    		iter.add( "GNRTRVER", new HeaderCard( "GNRTRVER", Utilities.getReleaseVersion(),
                            		"" ) );
                    		
                    		iter.add( "EXTNAME", new HeaderCard( "EXTNAME", "SPECTRUM",
                        		"" ) );
                    		
                    		fitsref.addHDU(extHdu);
                    	}
                    }
                    
                    OutputStream fo = new FileOutputStream( fileName );
                    BufferedDataOutputStream os = new BufferedDataOutputStream( fo );
                    fitsref.write( os );
                } 
                catch (Exception ex) {
                    ex.printStackTrace();
                }
        		break;
        	case STK:
        		try {
                    OutputStream file = new FileOutputStream( fileName );
                    OutputStream buffer = new GZIPOutputStream( file );
                    ObjectOutputStream out = new ObjectOutputStream( buffer );
                    out.writeObject( this );
                    out.close();
                } 
                catch (Exception ex) {
                    ex.printStackTrace();
                }
        		break;
        }
    }

    /**
     * Read a previous list of spectra stored as a serialised Gzipped
     * stream in a disk file (by the writeStack method). All recovered
     * spectra are append and converted in memory resident objects
     * (rather than retaining their associated with a disk file,
     * i.e. NDF, TEXT or FITS spectra).
     *
     * @param fileName name of the file containing the serialised data.
     * @return the number of spectra that are restored.
     */
    public int readStack( String fileName )
    {
        int restored = 0;
        try {
            InputStream file = new FileInputStream( fileName );
            restored = readStack( file );
            file.close();
        } 
        catch (Exception e) {
            e.printStackTrace();
        }
        return restored;
    }

    /**
     * Read a previous list of spectra stored as a serialised Gzipped
     * stream (must originate from the writeStack method). All recovered
     * spectra are append and converted in memory resident objects
     * (rather than retaining their associated with a disk file,
     * i.e. NDF, TEXT or FITS spectra).
     *
     * @param in the stream containing the serialised data.
     * @return the number of spectra that are restored.
     */
    public int readStack( InputStream in )
    {
        int restored = 0;
        try {
            InputStream buffer = new GZIPInputStream( in );
            ObjectInputStream oin = new ObjectInputStream( buffer );
            SpecList specList = (SpecList) oin.readObject();
            oin.close();
            buffer.close();
            GlobalSpecPlotList gList = GlobalSpecPlotList.getInstance();
            for ( int i = 0; i < specList.specCount(); i++ ) {
                SpecData specData = specList.get( i );
                gList.add( specList.get( i ) ); 
                restored++;
            }
        } 
        catch (Exception e) {
            e.printStackTrace();
        }
        return restored;
    }
}
