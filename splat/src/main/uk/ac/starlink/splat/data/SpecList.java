/*
 * Copyright (C) 2003 Central Laboratory of the Research Councils
 *
 *  History:
 *     28-SEP-2000 (Peter W. Draper):
 *       Original version.
 */
package uk.ac.starlink.splat.data;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import uk.ac.starlink.splat.iface.GlobalSpecPlotList;

/**
 * SpecList is a singleton object that contains references to all the
 * known spectra. The SpecList object should be updated with any new spectra
 * when they are created and also updated whenever a spectrum is
 * destroyed. Normally this task will be performed using the 
 * {@link GlobalSpecPlotList} object.
 *
 * @version $Id$
 * @author Peter W. Draper
 *
 * @see SpecDataFactory
 * @see "The Singleton Design Pattern"
 *
 */
public class SpecList implements Serializable
{
    /**
     *  Create the single class instance.
     */
    private static final SpecList instance = new SpecList();

    /**
     *  Hide the constructor from use.
     */
    private SpecList() {}

    /**
     *  Return reference to the only allowed instance of this class.
     */
    public static SpecList getInstance()
    {
        return instance;
    }

    /**
     *  ArrayList of references to spectra
     */
    protected ArrayList spectra = new ArrayList();

    /**
     *  Serialization version ID string (generated by serialver on
     *  original star.jspec.data.SpecList class).
     */
    static final long serialVersionUID = 6942346493134803694L;

    /**
     *  Get the number of spectra.
     */
    public int specCount()
    {
        return spectra.size();
    }

    /**
     *  Add a spectrum.
     */
    public int add( SpecData spectrum )
    {
        spectra.add( spectrum );
        return spectra.size() - 1;
    }

    /**
     *  Add or replace a spectrum.
     */
    public int add( int index, SpecData spectrum )
    {
        if ( index < specCount() ) {
            spectra.set( index, spectrum );
            return index;
        } 
        else {
            return add( spectrum );
        }
    }

    /**
     *  Remove a spectrum.
     */
    public int remove( SpecData spectrum )
    {
        int index = spectra.indexOf( spectrum );
        if ( index != -1 ) {
            spectra.remove( index );
        }
        return index;
    }

    /**
     *  Remove a spectrum.
     */
    public void remove( int index )
    {
        if ( index < specCount() ) {
            spectra.remove( index );
        }
    }

    /**
     *  Get a spectrum by index.
     */
    public SpecData get( int index )
    {
        if ( index < specCount() ) {
            return (SpecData)spectra.get( index );
        }
        return null;
    }

    /**
     *  Get the index of a spectrum.
     */
    public int indexOf( SpecData spectrum )
    {
        return spectra.indexOf( spectrum );
    }

    /**
     *  Return the index of a spectrum with the given short
     *  name. Returns -1 if unsuccessful.
     */
    public int indexOf( String shortName )
    {
        for ( int i = 0; i < spectra.size(); i++ ) {
            if ( getShortName( i ).equals( shortName ) ) {
                return i;
            }
        }
        return -1;
    }

    /**
     *  Return the full (i.e.<!-- --> disk file) name of a spectrum.
     */
    public String getFullName( int index )
    {
        if ( index < specCount() ) {
            return ((SpecData)spectra.get( index )).getFullName();
        }
        return null;
    }

    /**
     *  Return the symbolic name of a spectrum.
     */
    public String getShortName( int index )
    {
        if ( index < specCount() ) {
            return ((SpecData)spectra.get( index )).getShortName();
        }
        return null;
    }

    /**
     *  Set the symbolic name of a spectrum.
     */
    public void setShortName( int index, String name )
    {
        if ( index < specCount() ) {
            ((SpecData)spectra.get( index )).setShortName( name );
        }
    }

    /**
     *  Set the name of a spectrum.
     */
    public void setShortName( SpecData spectrum, String name )
    {
        spectrum.setShortName( name );
    }

    /**
     *  See if a spectrum is already present using its specification
     * (i.e.<!-- --> file name). Returns the index if found and -1 otherwise.
     */
    public int known( String fileName )
    {
        for ( int i = 0; i < spectra.size(); i++ ) {
            if ( ((SpecData)spectra.get(i)).getFullName().equals(fileName) ) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Save current state to a file as a serialised stream. The stream
     * is Gzipped to save space and should be restored using the
     * readStack method (which appends the previous state).
     */
    public void writeStack( String fileName )
    {
        try {
            OutputStream file = new FileOutputStream( fileName );
            OutputStream buffer = new GZIPOutputStream( file );
            ObjectOutputStream out = new ObjectOutputStream( buffer );
            out.writeObject( this );
            out.close();
        } 
        catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    /**
     * Read a previous list of spectra stored as a serialised Gzipped
     * stream in a disk file (by the writeStack method). All recovered
     * spectra are append and converted in memory resident objects
     * (rather than retaining their associated with a disk file,
     * i.e. NDF, TEXT or FITS spectra).
     *
     * @param fileName name of the file containing the serialised data.
     * @return the number of spectra that are restored.
     */
    public int readStack( String fileName )
    {
        int restored = 0;
        try {
            InputStream file = new FileInputStream( fileName );
            restored = readStack( file );
            file.close();
        } 
        catch (Exception e) {
            e.printStackTrace();
        }
        return restored;
    }

    /**
     * Read a previous list of spectra stored as a serialised Gzipped
     * stream (must originate from the writeStack method). All recovered
     * spectra are append and converted in memory resident objects
     * (rather than retaining their associated with a disk file,
     * i.e. NDF, TEXT or FITS spectra).
     *
     * @param in the stream containing the serialised data.
     * @return the number of spectra that are restored.
     */
    public int readStack( InputStream in )
    {
        int restored = 0;
        try {
            InputStream buffer = new GZIPInputStream( in );
            ObjectInputStream oin = new ObjectInputStream( buffer );
            SpecList specList = (SpecList) oin.readObject();
            oin.close();
            buffer.close();
            GlobalSpecPlotList gList = GlobalSpecPlotList.getInstance();
            for ( int i = 0; i < specList.specCount(); i++ ) {
                SpecData specData = specList.get( i );
                gList.add( specList.get( i ) ); 
                restored++;
            }
        } 
        catch (Exception e) {
            e.printStackTrace();
        }
        return restored;
    }
}
