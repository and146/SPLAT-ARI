 /*                  StarTaskSetter                  */
 /*  This places StarTaskRequests into the JavaSpace */
 /*  and awaits their completion.                    */ 
 /* ------------------------------------------------ */

package uk.ac.starlink.startask;
   
// Java util package
import java.util.ArrayList;
import java.util.Iterator;
     
// JavaSpacesUtil package
import uk.ac.starlink.jiniutils.SpaceAccessor;

// Jini core packages
import net.jini.core.lease.*;

// Jini extension package
import net.jini.space.JavaSpace;
     
// Starlink PCS
import uk.ac.starlink.jpcs.*;     

/** Places {@link StarTaskRequest}s into a JavaSpace. 
*/
public class StarTaskSetter {

         
/** Gets Starlink tasks run via {@link StarTaskRequest}s placed into a
*   JavaSpace.
*   <p>
*   The JavaSpace to be used is specified by a property file specified by the 
*   System property "uk.ac.starlink.startask.spacePropertyFile" (default
*   <code>star_space.prop</code>).
*   <p>
*   The requests are generated by a {@link StarTaskRequestGenerator} given the
*   arguments array, so that:
*   <ul>
*   <li>0 arguments is an error</li>
*   <li>1 argument is the name of a file containing command lines</li>
*   <li>&gt;1 arguments is taken as a single command line.</li>
*   </ul>
*   <p>
*   Command lines have the form: <i>Service task parameters...</i>
*   where: 
*   <dl>
*   <dt><i>Service</i></dt>
*   <dd> is the Starlink service class e.g. Kappa</dd>
*         <dt> <i>task</i></dt>
*   <dd> is the task method of the service class e..g. stats</dd>
*          <dt><i>parameters...</i></dt>
*   <dd> are the parameters, if any, for the task.</dd>
*   </dl>
*   <p>
*   If the command lines are read from a file,
*   <ul>
*   <li># introduces a comment line.</li>
*   <li>blank lines are ignored.</li>
*   <li>command lines may be continued on more than one line by escaping the
*     return with \.</li>
*   <li>{ introduces a set of commands which may be done in parallel
*     - the returned StarTaskRequest has the waitFlag set false.</li>
*   <li>} ends a set of parallel commands
*     - a StarTaskRequest with null service, task and parameter fields but with
*     the waitFlag set true is returned. The client should then wait for all
*     preceding requests to be serviced.</li>
*   </ul>
*/
   public static void main(String[] args) {
      StarTaskSetter setter = new StarTaskSetter();
      setter.run( args );
   }
   
   void run( String[] args ) {
         
System.out.println("START");
          
/* Get the space properties filename */
      String spacePropertyFile =
      System.getProperty( "uk.ac.starlink.startask.spacePropertyFile" );
      if( ( spacePropertyFile == null )
         || ( spacePropertyFile.length() == 0 ) ) {
         spacePropertyFile = "star_space.prop";
      }
            
/* Get the user's username */
      String username = System.getProperty( "user.name" ); 
                      
      try {

/* Get JavaSpace */     
//System.out.println("Get JavaSpace");
         SpaceAccessor newSpaceAccessor =
          new SpaceAccessor( spacePropertyFile );
         JavaSpace space = newSpaceAccessor.getSpace();
             
/* Create a template for replies */
         StarTaskReply template = new StarTaskReply();

/* Create a template for returned data packs */
         StarTaskDataPack dpTemplate = new StarTaskDataPack();
         
/* Create StarTaskRequestGenerator given the argument(s) */
         StarTaskRequestGenerator strg = new StarTaskRequestGenerator( args );

/* List of requests in progress */                 
         StarTaskJobList requests = new StarTaskJobList();

/* Dummy ( nowait request to get things going */
         StarTaskRequest str = new StarTaskRequest();
         str.setWait( false );

/* Initial ID number */
         int idNo = 1;
         
/* Data Pack */
         StarTaskDataPack dataPack = null;
                 
/* Loop generating requests until end of input */                 
         while( str != null ) {                   

/* If the request is not a dummy (wait) request */
            if( str.getPackage() != null ) {
               if( str.getPackage().equals( "DataPacket" ) ) {
                  String type = str.getTask();
                  String[] strpars = str.getParameters();
/*  In counting the parameters, we have to allow for the ACCEPT NOPROMPT
*   which is automatically added by the StarTaskRequestGenerator */
                  int npars = strpars.length - 2;
                  if( npars > 0 ) {
                     String[] pars = new String[npars];
                     System.arraycopy( strpars, 0, pars, 0, npars );

/*  Ensure a data pack is in use */
                     if( dataPack == null ) {
//System.out.println( "New StarTaskDataPack" );
                        dataPack = new StarTaskDataPack();
                     }
                     
                     dataPack.add( type, pars );
                     
                  } else {
                     throw new StarTaskException(
                      "No parameters for StarTaskDataPacket" );
                  }
                              
               } else {
/*  A normal StarTaskRequest */                  
/*  set an Id for it */
//System.out.println( "Normal request" );
                  StarTaskRequestId id =
                   new StarTaskRequestId( username, idNo++ );
                  str.putId( id );
               
/*  If there is a data pack, put it into space first with an id associating
*   it with this request, then annul it.
*/
                  if( dataPack != null ) {
//System.out.println( "Write datapack into space" );
                     dataPack.setId( id );
                     space.write( dataPack, null, Lease.FOREVER );
                     dataPack = null;
                  }

/*  and inform the user */
/*  Display request */
                  str.display();
                  System.out.println( "\nSetting task:" );

/*  and send it into space */
                  space.write( str, null, Lease.FOREVER );

/*  and add it to the list. */
                  requests.add( new StarTaskJob( str ) );
               }
            }
                      
/* If the waitFlag is set, wait for all previous requests to be serviced */
            if( str.getWait() ) {
//System.out.println( "Awaiting: " + requests.size() );
               while( requests.getIncompleteJobs().size() > 0 ) {
                     StarTaskReply reply = null;
                  for( int idIndex=0;idIndex<requests.size();idIndex++) {
                     StarTaskRequest request =
                      ((StarTaskJob)(requests.get( idIndex ))).getRequest();
                     StarTaskRequestId id = request.getId();
//request.display();
//System.out.println( "Looking for reply id " + id.toString() ); 
/* Look for the reply with each id in turn - If one is found, process it and 
*   start again at the begining of the list - this will favour correct 
*   ordering of outputs
*/
                     template.reqId = id;
                     reply = null;
                    
/*                    See if this request reply exists */
                     reply = (StarTaskReply)space.takeIfExists(
                              template, null, Long.MAX_VALUE );
                     if( reply != null ) {
/*                    If it does, set progress 'done' */
//                        requests.remove( idIndex );
                         Object obj = requests.get( idIndex );
                 ((StarTaskJob)obj).setDone( true );  

/*                    and process the reply */
                        reply.taskReply.getMsg().flush();

/*                    See if there is a returned datapack */
                        dpTemplate.reqId = id; 
                        StarTaskDataPack returnedDP =
                         (StarTaskDataPack)space.takeIfExists(
                              dpTemplate, null, Long.MAX_VALUE );

/*                    If there is, make local copies of the files */
                        if( returnedDP != null ) {
                           returnedDP.makeLocal();
                        }
                        
/*                    and force start again at the beginning of the list */
                        idIndex = 0;
                     } else {
/*                    See if the job has been accepted */
//System.out.println( "See if " + id.toString() + " is accepted" );
//request.display();
                        StarTaskAcceptance acceptance =
                         (StarTaskAcceptance)space.readIfExists(
                           new StarTaskAcceptance( null, request ),
                            null, Long.MAX_VALUE );
                        if( acceptance != null ) {
//                           System.out.println(
//                           "Request " + acceptance.getId().toString() + 
//                           " running on " + acceptance.getServer() );
//acceptance.starRequest.display();
                           ((StarTaskJob)(requests.get( idIndex )))
                            .setAcceptor( acceptance.getServer() );
  
                           
                        }
                     } 
                                     
                  }   // do for next in list
                       
/* If none of the requests have been serviced, wait a while */
                  if( requests.size() > 0 ) {
                     Thread.sleep( 500 );
                  }

/* Uncomment the next line for a printout of the current jobList */                  
//                  plot( requests );
                  
               } //  go through the waiting list again
            }

/*  Get the next request */
            str = strg.nextRequest();

         }  //  do for the next request
                   
            
      } catch(Exception e) {
         e.printStackTrace();
      }
             
System.out.println("END");
      System.exit(0);
   }
   

/** Display the requests list.
  * This is available for diagnostic purposes
  * @param list an list of StarTaskJob Objects.
  */
   static void plot( StarTaskJobList list ) {

      System.out.println(
       "Number of incomplete jobs: " + list.getIncompleteJobs().size() );

/* Get a list of the servers used */
      String[] servers = list.getServers();

/* For each server, display the list of jobs */
      if( servers.length > 0 ) {
         for( int i=0;i<servers.length;i++ ) {
            StarTaskJobList jobs = list.getServerJobs( servers[i] );
            Iterator it = jobs.iterator();
            System.out.println( "Jobs for " + servers[i] );
            while( it.hasNext() ) {
               ((StarTaskJob)it.next()).display();
            }
         }
      }
   }
}         
